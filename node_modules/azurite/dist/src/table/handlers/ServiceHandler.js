"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const TableStorageContext_1 = tslib_1.__importDefault(require("../context/TableStorageContext"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const Models = tslib_1.__importStar(require("../generated/artifacts/models"));
const xml_1 = require("../generated/utils/xml");
const constants_1 = require("../utils/constants");
const BaseHandler_1 = tslib_1.__importDefault(require("./BaseHandler"));
class ServiceHandler extends BaseHandler_1.default {
    constructor() {
        super(...arguments);
        /**
         * Default service properties.
         *
         * @private
         * @memberof ServiceHandler
         */
        this.defaultServiceProperties = {
            cors: [],
            defaultServiceVersion: constants_1.TABLE_API_VERSION,
            hourMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            },
            logging: {
                deleteProperty: true,
                read: true,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0",
                write: true
            },
            minuteMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            }
        };
    }
    // https://docs.microsoft.com/en-us/rest/api/storageservices/get-table-service-properties
    async getProperties(options, context) {
        const tableCtx = new TableStorageContext_1.default(context);
        const accountName = tableCtx.account;
        let properties = await this.metadataStore.getServiceProperties(context, accountName);
        if (!properties) {
            properties = { ...this.defaultServiceProperties, accountName };
        }
        if (properties.cors === undefined) {
            properties.cors = [];
        }
        if (properties.hourMetrics === undefined) {
            properties.hourMetrics = this.defaultServiceProperties.hourMetrics;
        }
        if (properties.logging === undefined) {
            properties.logging = this.defaultServiceProperties.logging;
        }
        if (properties.minuteMetrics === undefined) {
            properties.minuteMetrics = this.defaultServiceProperties.minuteMetrics;
        }
        const response = {
            ...properties,
            requestId: context.contextID,
            statusCode: 200,
            version: constants_1.TABLE_API_VERSION,
            clientRequestId: options.requestId
        };
        return response;
    }
    async setProperties(tableServiceProperties, options, context) {
        const tableCtx = new TableStorageContext_1.default(context);
        const accountName = tableCtx.account;
        // TODO: deserializor has a bug that when cors is undefined,
        // it will serialize it to empty array instead of undefined
        const body = tableCtx.request.getBody();
        const parsedBody = await (0, xml_1.parseXML)(body || "");
        if (!Object.hasOwnProperty.bind(parsedBody)('cors') &&
            !Object.hasOwnProperty.bind(parsedBody)('Cors')) {
            tableServiceProperties.cors = undefined;
        }
        // Azure Storage allows allowedHeaders and exposedHeaders to be empty,
        // Azurite will set to empty string for this scenario
        for (const cors of tableServiceProperties.cors || []) {
            cors.allowedHeaders = cors.allowedHeaders || "";
            cors.exposedHeaders = cors.exposedHeaders || "";
        }
        await this.metadataStore.setServiceProperties(context, {
            ...tableServiceProperties,
            accountName
        });
        const response = {
            requestId: context.contextID,
            statusCode: 202,
            version: constants_1.TABLE_API_VERSION,
            clientRequestId: options.requestId
        };
        return response;
    }
    async getStatistics(options, context) {
        if (!context.context.isSecondary) {
            throw StorageErrorFactory_1.default.getInvalidQueryParameterValue(context);
        }
        const response = {
            statusCode: 200,
            requestId: context.contextID,
            version: constants_1.TABLE_API_VERSION,
            date: context.startTime,
            geoReplication: {
                status: Models.GeoReplicationStatusType.Live,
                lastSyncTime: context.startTime
            },
            clientRequestId: options.requestId
        };
        return response;
    }
}
exports.default = ServiceHandler;
//# sourceMappingURL=ServiceHandler.js.map