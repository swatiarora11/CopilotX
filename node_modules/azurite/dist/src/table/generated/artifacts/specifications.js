"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
// tslint:disable:object-literal-sort-keys
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const msRest = tslib_1.__importStar(require("@azure/ms-rest-js"));
const Mappers = tslib_1.__importStar(require("./mappers"));
const operation_1 = require("./operation");
const Parameters = tslib_1.__importStar(require("./parameters"));
const serializer = new msRest.Serializer(Mappers, true);
// specifications for new method group start
const tableQueryOperationSpec = {
    httpMethod: "GET",
    path: "Tables",
    urlParameters: [Parameters.url],
    queryParameters: [
        Parameters.nextTableName,
        Parameters.format,
        Parameters.top,
        Parameters.select,
        Parameters.filter
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion
    ],
    responses: {
        200: {
            bodyMapper: Mappers.TableQueryResponse,
            headersMapper: Mappers.TableQueryHeaders
        },
        default: {}
    },
    isXML: true,
    serializer
};
const tableCreateOperationSpec = {
    httpMethod: "POST",
    path: "Tables",
    urlParameters: [Parameters.url],
    queryParameters: [Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.responsePreference
    ],
    requestBody: {
        parameterPath: "tableProperties",
        mapper: {
            ...Mappers.TableProperties,
            required: true
        }
    },
    contentType: "application/json;odata=nometadata; charset=utf-8",
    responses: {
        201: {
            bodyMapper: Mappers.TableResponse,
            headersMapper: Mappers.TableCreateHeaders
        },
        204: {
            headersMapper: Mappers.TableCreateHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableBatchOperationSpec = {
    httpMethod: "POST",
    path: "$batch",
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.multipartContentType,
        Parameters.contentLength
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/json;odata=nometadata; charset=utf-8",
    responses: {
        202: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.TableBatchHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableDeleteOperationSpec = {
    httpMethod: "DELETE",
    path: "Tables('{table}')",
    urlParameters: [Parameters.url, Parameters.table],
    headerParameters: [Parameters.version, Parameters.requestId],
    responses: {
        204: {
            headersMapper: Mappers.TableDeleteHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableQueryEntitiesOperationSpec = {
    httpMethod: "GET",
    path: "{table}()",
    urlParameters: [Parameters.url, Parameters.table],
    queryParameters: [
        Parameters.timeout,
        Parameters.nextPartitionKey,
        Parameters.nextRowKey,
        Parameters.format,
        Parameters.top,
        Parameters.select,
        Parameters.filter
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.TableQueryEntitiesHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableQueryEntitiesWithPartitionAndRowKeyOperationSpec = {
    httpMethod: "GET",
    path: "{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    urlParameters: [
        Parameters.url,
        Parameters.table,
        Parameters.partitionKey,
        Parameters.rowKey
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.format,
        Parameters.select,
        Parameters.filter
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.TableQueryEntitiesWithPartitionAndRowKeyHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableUpdateEntityOperationSpec = {
    httpMethod: "PUT",
    path: "{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    urlParameters: [
        Parameters.url,
        Parameters.table,
        Parameters.partitionKey,
        Parameters.rowKey
    ],
    queryParameters: [Parameters.timeout, Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.ifMatch0
    ],
    requestBody: {
        parameterPath: ["options", "tableEntityProperties"],
        mapper: {
            serializedName: "tableEntityProperties",
            type: {
                name: "Dictionary",
                value: {
                    type: {
                        name: "Object"
                    }
                }
            }
        }
    },
    responses: {
        204: {
            headersMapper: Mappers.TableUpdateEntityHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableMergeEntityOperationSpec = {
    httpMethod: "PATCH",
    path: "{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    urlParameters: [
        Parameters.url,
        Parameters.table,
        Parameters.partitionKey,
        Parameters.rowKey
    ],
    queryParameters: [Parameters.timeout, Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.ifMatch0
    ],
    requestBody: {
        parameterPath: ["options", "tableEntityProperties"],
        mapper: {
            serializedName: "tableEntityProperties",
            type: {
                name: "Dictionary",
                value: {
                    type: {
                        name: "Object"
                    }
                }
            }
        }
    },
    responses: {
        204: {
            headersMapper: Mappers.TableMergeEntityHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableDeleteEntityOperationSpec = {
    httpMethod: "DELETE",
    path: "{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    urlParameters: [
        Parameters.url,
        Parameters.table,
        Parameters.partitionKey,
        Parameters.rowKey
    ],
    queryParameters: [Parameters.timeout, Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.ifMatch1
    ],
    responses: {
        204: {
            headersMapper: Mappers.TableDeleteEntityHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableMergeEntityWithMergeOperationSpec = {
    httpMethod: "POST",
    path: "{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')",
    urlParameters: [
        Parameters.url,
        Parameters.table,
        Parameters.partitionKey,
        Parameters.rowKey
    ],
    queryParameters: [Parameters.timeout, Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.ifMatch0
    ],
    requestBody: {
        parameterPath: ["options", "tableEntityProperties"],
        mapper: {
            serializedName: "tableEntityProperties",
            type: {
                name: "Dictionary",
                value: {
                    type: {
                        name: "Object"
                    }
                }
            }
        }
    },
    responses: {
        204: {
            headersMapper: Mappers.TableMergeEntityWithMergeHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableInsertEntityOperationSpec = {
    httpMethod: "POST",
    path: "{table}",
    urlParameters: [Parameters.url, Parameters.table],
    queryParameters: [Parameters.timeout, Parameters.format],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.dataServiceVersion,
        Parameters.responsePreference
    ],
    requestBody: {
        parameterPath: ["options", "tableEntityProperties"],
        mapper: {
            serializedName: "tableEntityProperties",
            type: {
                name: "Dictionary",
                value: {
                    type: {
                        name: "Object"
                    }
                }
            }
        }
    },
    contentType: "application/json;odata=nometadata; charset=utf-8",
    responses: {
        201: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.TableInsertEntityHeaders
        },
        204: {
            headersMapper: Mappers.TableInsertEntityHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableGetAccessPolicyOperationSpec = {
    httpMethod: "GET",
    path: "{table}",
    urlParameters: [Parameters.url, Parameters.table],
    queryParameters: [Parameters.timeout, Parameters.comp0],
    headerParameters: [Parameters.version, Parameters.requestId],
    responses: {
        200: {
            bodyMapper: {
                xmlElementName: "SignedIdentifier",
                serializedName: "SignedIdentifiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            },
            headersMapper: Mappers.TableGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const tableSetAccessPolicyOperationSpec = {
    httpMethod: "PUT",
    path: "{table}",
    urlParameters: [Parameters.url, Parameters.table],
    queryParameters: [Parameters.timeout, Parameters.comp0],
    headerParameters: [Parameters.version, Parameters.requestId],
    requestBody: {
        parameterPath: ["options", "tableAcl"],
        mapper: {
            xmlName: "SignedIdentifiers",
            xmlElementName: "SignedIdentifier",
            serializedName: "tableAcl",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "Composite",
                        className: "SignedIdentifier"
                    }
                }
            }
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        204: {
            headersMapper: Mappers.TableSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const serviceSetPropertiesOperationSpec = {
    httpMethod: "PUT",
    urlParameters: [Parameters.url],
    queryParameters: [Parameters.timeout, Parameters.restype, Parameters.comp1],
    headerParameters: [Parameters.version, Parameters.requestId],
    requestBody: {
        parameterPath: "tableServiceProperties",
        mapper: {
            ...Mappers.TableServiceProperties,
            required: true
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        202: {
            headersMapper: Mappers.ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const serviceGetPropertiesOperationSpec = {
    httpMethod: "GET",
    urlParameters: [Parameters.url],
    queryParameters: [Parameters.restype, Parameters.comp1, Parameters.timeout],
    headerParameters: [Parameters.version, Parameters.requestId],
    responses: {
        200: {
            bodyMapper: Mappers.TableServiceProperties,
            headersMapper: Mappers.ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const serviceGetStatisticsOperationSpec = {
    httpMethod: "GET",
    urlParameters: [Parameters.url],
    queryParameters: [Parameters.timeout, Parameters.restype, Parameters.comp2],
    headerParameters: [Parameters.version, Parameters.requestId],
    responses: {
        200: {
            bodyMapper: Mappers.TableServiceStats,
            headersMapper: Mappers.ServiceGetStatisticsHeaders
        },
        default: {
            bodyMapper: Mappers.TableServiceError
        }
    },
    isXML: true,
    serializer
};
const Specifications = {};
Specifications[operation_1.Operation.Table_Query] = tableQueryOperationSpec;
Specifications[operation_1.Operation.Table_Create] = tableCreateOperationSpec;
Specifications[operation_1.Operation.Table_Batch] = tableBatchOperationSpec;
Specifications[operation_1.Operation.Table_Delete] = tableDeleteOperationSpec;
Specifications[operation_1.Operation.Table_QueryEntities] = tableQueryEntitiesOperationSpec;
Specifications[operation_1.Operation.Table_QueryEntitiesWithPartitionAndRowKey] = tableQueryEntitiesWithPartitionAndRowKeyOperationSpec;
Specifications[operation_1.Operation.Table_UpdateEntity] = tableUpdateEntityOperationSpec;
Specifications[operation_1.Operation.Table_MergeEntity] = tableMergeEntityOperationSpec;
Specifications[operation_1.Operation.Table_DeleteEntity] = tableDeleteEntityOperationSpec;
Specifications[operation_1.Operation.Table_MergeEntityWithMerge] = tableMergeEntityWithMergeOperationSpec;
Specifications[operation_1.Operation.Table_InsertEntity] = tableInsertEntityOperationSpec;
Specifications[operation_1.Operation.Table_GetAccessPolicy] = tableGetAccessPolicyOperationSpec;
Specifications[operation_1.Operation.Table_SetAccessPolicy] = tableSetAccessPolicyOperationSpec;
Specifications[operation_1.Operation.Service_SetProperties] = serviceSetPropertiesOperationSpec;
Specifications[operation_1.Operation.Service_GetProperties] = serviceGetPropertiesOperationSpec;
Specifications[operation_1.Operation.Service_GetStatistics] = serviceGetStatisticsOperationSpec;
exports.default = Specifications;
//# sourceMappingURL=specifications.js.map