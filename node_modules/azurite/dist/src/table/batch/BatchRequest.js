"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const BatchRequestHeaders_1 = tslib_1.__importDefault(require("./BatchRequestHeaders"));
const Models = tslib_1.__importStar(require("../generated/artifacts/models"));
const BatchTableUpdateEntityOptionalParams_1 = tslib_1.__importDefault(require("./BatchTableUpdateEntityOptionalParams"));
const BatchTableDeleteEntityOptionalParams_1 = tslib_1.__importDefault(require("./BatchTableDeleteEntityOptionalParams"));
const BatchStringConstants_1 = tslib_1.__importDefault(require("./BatchStringConstants"));
const BatchErrorConstants_1 = tslib_1.__importDefault(require("./BatchErrorConstants"));
/*
 * Represents a request in the context of batch operations.
 * ToDo: Requires validation against all operation types
 * Currently several funcitons of the interface are not implemented
 * @export
 * @class BatchRequest
 * @implements {IRequest}
 */
class BatchRequest {
    constructor(batchOperation) {
        this.batchOperation = batchOperation;
        this.headers = new BatchRequestHeaders_1.default(batchOperation.rawHeaders);
        // set default params, due to our processing logic
        this.params = new BatchTableUpdateEntityOptionalParams_1.default();
    }
    // ingests the optional params for a batch request, and sets these
    // based on the type of operation and headers present on an
    // individual request
    ingestOptionalParams(params) {
        this.params = params;
        // need to compare headers to option params and set accordingly
        if (this.getHeader(BatchStringConstants_1.default.MS_CLIENT_REQ_ID) !== undefined) {
            this.params.requestId = this.getHeader(BatchStringConstants_1.default.MS_CLIENT_REQ_ID);
        }
        // Theoretically, this Enum is redundant, and used across all table
        // optional param models, thinking that we only need to use the 1,
        // the code generator is however differentiating across all of them
        // as distinct
        if (this.getHeader(BatchStringConstants_1.default.DATASERVICEVERSION)?.includes("3.0")) {
            this.params.dataServiceVersion =
                Models.DataServiceVersion4.ThreeFullStopZero;
        }
        // TableDeleteEntityOptionalParams is the only interface without a body
        // I instantiate the batch class to enable this check and the other
        // interface acrobatics needed for batch processing
        const body = this.getBody();
        if (body != null &&
            body !== "" &&
            !(this.params instanceof BatchTableDeleteEntityOptionalParams_1.default)) {
            this.params.tableEntityProperties = JSON.parse(body);
        }
        // set request timeout
        // https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-table-service-operations
        // set responsePreference
        // set queryOptions
        // https://docs.microsoft.com/en-us/rest/api/storageservices/payload-format-for-table-service-operations
        const options = new Object();
        // format
        // set payload options
        if (this.getHeader(BatchStringConstants_1.default.ACCEPT)?.includes(BatchStringConstants_1.default.MINIMAL_META)) {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodataminimalmetadata;
        }
        else if (this.getHeader(BatchStringConstants_1.default.ACCEPT)?.includes(BatchStringConstants_1.default.FULL_META)) {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodatafullmetadata;
        }
        else {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodatanometadata;
        }
        // top
        // select
        // filter
        this.params.queryOptions = options;
    }
    getMethod() {
        if (this.batchOperation.httpMethod != null) {
            return this.batchOperation.httpMethod;
        }
        else {
            throw new Error(BatchErrorConstants_1.default.METHOD_INVALID);
        }
    }
    getUrl() {
        // ToDo: is this a valid assumption for the batch API?
        // ToDo: here we also assume https, which is also not true...
        // we need to parse this from the request
        // return `https://${this.accountName}.${this.batchOperation.batchType}.core.windows.net/$batch`;
        // in delete, it seems that we actuall expect the full uri
        if (this.batchOperation.uri != null && this.batchOperation.path != null) {
            return this.batchOperation.uri;
        }
        else {
            throw new Error(BatchErrorConstants_1.default.URI_NULL);
        }
    }
    getEndpoint() {
        throw new Error(BatchErrorConstants_1.default.METHOD_NOT_IMPLEMENTED);
    }
    getPath() {
        if (this.batchOperation.path != null) {
            return this.batchOperation.path;
        }
        else {
            throw new Error(BatchErrorConstants_1.default.PATH_NULL);
        }
    }
    getBodyStream() {
        if (this.batchOperation.jsonRequestBody != null) {
            return stream_1.Stream.Readable.from(this.batchOperation.jsonRequestBody);
        }
        else {
            throw new Error(BatchErrorConstants_1.default.BODY_NULL);
        }
    }
    setBody(body) {
        throw new Error(BatchErrorConstants_1.default.METHOD_NOT_IMPLEMENTED);
    }
    getBody() {
        if (this.batchOperation.jsonRequestBody != null) {
            return this.batchOperation.jsonRequestBody;
        }
        else {
            throw new Error(BatchErrorConstants_1.default.BODY_NULL);
        }
    }
    getHeader(field) {
        return this.headers.header(field);
    }
    getHeaders() {
        throw new Error(BatchErrorConstants_1.default.METHOD_NOT_IMPLEMENTED);
    }
    getRawHeaders() {
        return this.batchOperation.rawHeaders;
    }
    getQuery(key) {
        switch (key) {
            case BatchStringConstants_1.default.FORMAT:
                return this.params.queryOptions?.format;
            case BatchStringConstants_1.default.TOP:
                return this.params.queryOptions?.top?.toLocaleString();
            case BatchStringConstants_1.default.SELECT:
                return this.params.queryOptions?.select;
            case BatchStringConstants_1.default.FILTER:
                return this.params.queryOptions?.filter;
            default:
                break;
        }
        throw new Error(BatchErrorConstants_1.default.UNKNOWN_QUERYOPTION);
    }
    getProtocol() {
        if (this.batchOperation.protocol !== null &&
            this.batchOperation.protocol !== undefined) {
            return this.batchOperation.protocol;
        }
        else {
            // try extract protocol
            const protocolMatch = this.getUrl().match(/https?/);
            if (protocolMatch !== null && protocolMatch.length > 0) {
                this.batchOperation.protocol = protocolMatch[0];
                return this.batchOperation.protocol;
            }
            throw new Error(BatchErrorConstants_1.default.PROTOCOL_NULL);
        }
    }
}
exports.default = BatchRequest;
//# sourceMappingURL=BatchRequest.js.map