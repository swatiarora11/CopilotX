"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEntityProperty = exports.EntityProperty = exports.toAnnotationLevel = exports.AnnotationLevel = void 0;
const constants_1 = require("../utils/constants");
const EdmBinary_1 = require("./EdmBinary");
const EdmBoolean_1 = require("./EdmBoolean");
const EdmDateTime_1 = require("./EdmDateTime");
const EdmDouble_1 = require("./EdmDouble");
const EdmGuid_1 = require("./EdmGuid");
const EdmInt32_1 = require("./EdmInt32");
const EdmInt64_1 = require("./EdmInt64");
const EdmNull_1 = require("./EdmNull");
const EdmString_1 = require("./EdmString");
const IEdmType_1 = require("./IEdmType");
var AnnotationLevel;
(function (AnnotationLevel) {
    AnnotationLevel[AnnotationLevel["FULL"] = 0] = "FULL";
    AnnotationLevel[AnnotationLevel["MINIMAL"] = 1] = "MINIMAL";
    AnnotationLevel[AnnotationLevel["NO"] = 2] = "NO";
})(AnnotationLevel || (exports.AnnotationLevel = AnnotationLevel = {}));
function toAnnotationLevel(level) {
    switch (level) {
        case constants_1.MINIMAL_METADATA_ACCEPT:
            return AnnotationLevel.MINIMAL;
        case constants_1.FULL_METADATA_ACCEPT:
            return AnnotationLevel.FULL;
        case constants_1.NO_METADATA_ACCEPT:
            return AnnotationLevel.NO;
        default:
            throw TypeError(`Invalid OData annonation level ${level}.`);
    }
}
exports.toAnnotationLevel = toAnnotationLevel;
class EntityProperty {
    constructor(name, value, edmType, isSystemProperty = false) {
        this.name = name;
        this.value = value;
        this.edmType = edmType;
        this.isSystemProperty = isSystemProperty;
    }
    toJsonPropertyValuePair() {
        return this.edmType.toJsonPropertyValuePair(this.name);
    }
    toJsonPropertyValueString() {
        return this.edmType.toJsonPropertyValueString(this.name);
    }
    toJsonPropertyTypePair(annotationLevel, force = false) {
        return this.edmType.toJsonPropertyTypePair(this.name, annotationLevel, this.isSystemProperty, force);
    }
    toJsonPropertyTypeString(annotationLevel) {
        return this.edmType.toJsonPropertyTypeString(this.name, annotationLevel, this.isSystemProperty);
    }
    toResponseString(annotationLevel) {
        const level = typeof annotationLevel === "string"
            ? toAnnotationLevel(annotationLevel)
            : annotationLevel;
        const typeString = this.toJsonPropertyTypeString(level);
        const propertyString = this.toJsonPropertyValueString();
        if (typeString) {
            return [typeString, propertyString].join(",");
        }
        else {
            return propertyString;
        }
    }
    normalize(entity) {
        // Set back to Entity
        const pair = this.toJsonPropertyValuePair();
        if (!pair) {
            return;
        }
        const [key, value] = pair;
        entity.properties[key] = value;
        const res = this.toJsonPropertyTypePair(AnnotationLevel.FULL, true);
        if (res) {
            const [typeKey, typeValue] = res;
            entity.properties[typeKey] = typeValue;
        }
    }
}
exports.EntityProperty = EntityProperty;
function parseEntityProperty(name, value, edmType, isSystemProperty = false) {
    if (edmType !== undefined) {
        // Validate values per input EdmType
        const type = typeof edmType === "string" ? (0, IEdmType_1.getEdmType)(edmType) : edmType;
        switch (type) {
            case IEdmType_1.EdmType.Binary:
                // EdmBinary.validate(value);
                return new EntityProperty(name, value, new EdmBinary_1.EdmBinary(value), isSystemProperty);
            case IEdmType_1.EdmType.Boolean:
                // EdmBoolean.validate(value);
                return new EntityProperty(name, value, new EdmBoolean_1.EdmBoolean(value), isSystemProperty);
            case IEdmType_1.EdmType.DateTime:
                EdmDateTime_1.EdmDateTime.validate(value);
                return new EntityProperty(name, value, new EdmDateTime_1.EdmDateTime(value), isSystemProperty);
            case IEdmType_1.EdmType.Double:
                const dblval = EdmDouble_1.EdmDouble.validate(value);
                return new EntityProperty(name, dblval, new EdmDouble_1.EdmDouble(dblval), isSystemProperty);
            case IEdmType_1.EdmType.Guid:
                EdmGuid_1.EdmGuid.validate(value);
                return new EntityProperty(name, value, new EdmGuid_1.EdmGuid(value), isSystemProperty);
            case IEdmType_1.EdmType.Int32:
                EdmInt32_1.EdmInt32.validate(value);
                return new EntityProperty(name, value, new EdmInt32_1.EdmInt32(value), isSystemProperty);
            case IEdmType_1.EdmType.Int64:
                EdmInt64_1.EdmInt64.validate(value);
                return new EntityProperty(name, value, new EdmInt64_1.EdmInt64(value), isSystemProperty);
            case IEdmType_1.EdmType.String:
                EdmString_1.EdmString.validate(value);
                return new EntityProperty(name, value, new EdmString_1.EdmString(value), isSystemProperty);
            default:
                throw TypeError(`Invalid EdmType ${type}.`);
        }
    }
    else {
        // Extract type from value type
        switch (typeof value) {
            case "string":
                EdmString_1.EdmString.validate(value);
                return new EntityProperty(name, value, new EdmString_1.EdmString(value));
            case "number":
                if (Number.isInteger(value)) {
                    EdmInt32_1.EdmInt32.validate(value);
                    return new EntityProperty(name, value, new EdmInt32_1.EdmInt32(value));
                }
                else {
                    EdmDouble_1.EdmDouble.validate(value);
                    return new EntityProperty(name, value, new EdmDouble_1.EdmDouble(value));
                }
            case "boolean":
                EdmBoolean_1.EdmBoolean.validate(value);
                return new EntityProperty(name, value, new EdmBoolean_1.EdmBoolean(value));
            case "object":
                if (value === null) {
                    return new EntityProperty(name, value, new EdmNull_1.EdmNull(value));
                }
            default:
                throw TypeError(`Invalid value when parsing EdmType ${value}.`);
        }
    }
}
exports.parseEntityProperty = parseEntityProperty;
//# sourceMappingURL=EntityProperty.js.map