"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NormalizedEntity = void 0;
const utils_1 = require("../../common/utils/utils");
const constants_1 = require("../utils/constants");
const EdmString_1 = require("./EdmString");
const EntityProperty_1 = require("./EntityProperty");
// import { EdmType } from "./IEdmType";
class NormalizedEntity {
    constructor(entity) {
        this.properties = [];
        this.propertiesMap = {};
        this.ref = entity;
        // Partition Key
        const partitionKeyProperty = new EntityProperty_1.EntityProperty("PartitionKey", entity.PartitionKey, new EdmString_1.EdmString(entity.PartitionKey), true);
        this.properties.push(partitionKeyProperty);
        this.propertiesMap.PartitionKey = partitionKeyProperty;
        // Row Key
        const rowKeyProperty = new EntityProperty_1.EntityProperty("RowKey", entity.RowKey, new EdmString_1.EdmString(entity.RowKey), true);
        this.properties.push(rowKeyProperty);
        this.propertiesMap.RowKey = rowKeyProperty;
        // Sync Timestamp from entity last modified time
        entity.properties.Timestamp =
            typeof entity.lastModifiedTime === "string" &&
                entity.lastModifiedTime === ""
                ? (0, utils_1.truncatedISO8061Date)(new Date(), true, true)
                : entity.lastModifiedTime;
        entity.properties["Timestamp@odata.type"] = "Edm.DateTime";
        for (const key in entity.properties) {
            if (Object.prototype.hasOwnProperty.call(entity.properties, key)) {
                const element = entity.properties[key];
                if (this.propertiesMap[key] !== undefined) {
                    continue;
                }
                if (key.endsWith(constants_1.ODATA_TYPE)) {
                    continue;
                }
                else {
                    const type = entity.properties[`${key}${constants_1.ODATA_TYPE}`];
                    if (type !== undefined && typeof type !== "string") {
                        throw RangeError(`Invalid EdmType value:${type} for key:${key}${constants_1.ODATA_TYPE}`);
                    }
                    const property = this.validateSystemProperty(key, element, type);
                    this.properties.push(property);
                    this.propertiesMap[key] = property;
                }
            }
        }
    }
    /**
     * Removes oData type from Timestamp property
     *
     * @private
     * @param {string} key
     * @param {(string | number | boolean | null)} element
     * @param {string} type
     * @return {*}
     * @memberof NormalizedEntity
     */
    validateSystemProperty(key, element, type) {
        let isSystemProperty = false;
        if (key === "Timestamp") {
            isSystemProperty = true;
        }
        const property = (0, EntityProperty_1.parseEntityProperty)(key, element, type, isSystemProperty);
        return property;
    }
    // Convert to HTTP response payload string
    toResponseString(annotationLevel, injections, includes) {
        const pairs = [];
        for (const key in injections) {
            if (Object.prototype.hasOwnProperty.call(injections, key)) {
                const value = injections[key];
                pairs.push(`"${key}":${JSON.stringify(value)}`);
            }
        }
        for (const pair of this.properties) {
            if (!includes || includes.has(pair.name)) {
                const str = pair.toResponseString(annotationLevel);
                if (str) {
                    pairs.push(str);
                }
            }
        }
        return `{${pairs.join(",")}}`;
    }
    normalize() {
        this.ref.properties = {};
        for (const entity of this.properties) {
            entity.normalize(this.ref);
        }
        return this.ref;
    }
}
exports.NormalizedEntity = NormalizedEntity;
//# sourceMappingURL=NormalizedEntity.js.map