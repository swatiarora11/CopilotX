"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const StorageError_1 = tslib_1.__importDefault(require("./StorageError"));
const defaultID = "DefaultID";
// see: https://learn.microsoft.com/en-us/rest/api/storageservices/table-service-error-codes
class StorageErrorFactory {
    static getBatchDuplicateRowKey(context, rowKey) {
        return new StorageError_1.default(400, "InvalidDuplicateRow", `A command with RowKey '${rowKey}' is already present in the batch. An entity can appear only once in a batch. `, context.contextID || defaultID, undefined, context);
    }
    static getInvalidHeaderValue(context, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", context.contextID || defaultID, additionalMessages, context);
    }
    static getInvalidAPIVersion(context, apiVersion) {
        return new StorageError_1.default(400, "InvalidHeaderValue", `The API version ${apiVersion} is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter \"--skipApiVersionCheck\" or Visual Studio Code configuration \"Skip Api Version Check\" can skip this error. `, context.contextID || defaultID, undefined, context);
    }
    static getInvalidInput(context, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidInput", "An error occurred while processing this request.", context.contextID || defaultID, additionalMessages, context);
    }
    static getTableAlreadyExists(context) {
        return new StorageError_1.default(409, "TableAlreadyExists", "The table specified already exists.", context.contextID || defaultID, undefined, context);
    }
    static getTableNameEmpty(context) {
        return new StorageError_1.default(400, "TableNameEmpty", "The specified table name is empty.", context.contextID || defaultID, undefined, context);
    }
    static getInvalidOperation(context, message = "") {
        return new StorageError_1.default(400, "InvalidOperation", message, context.contextID || "", undefined, context);
    }
    static getAuthorizationSourceIPMismatch(context) {
        return new StorageError_1.default(403, "AuthorizationSourceIPMismatch", "This request is not authorized to perform this operation using this source IP {SourceIP}.", context.contextID || defaultID, undefined, context);
    }
    static getAuthorizationProtocolMismatch(context) {
        return new StorageError_1.default(403, "AuthorizationProtocolMismatch", "This request is not authorized to perform this operation using this protocol.", context.contextID || defaultID, undefined, context);
    }
    static getAuthorizationPermissionMismatch(context) {
        return new StorageError_1.default(403, "AuthorizationPermissionMismatch", "This request is not authorized to perform this operation using this permission.", context.contextID || defaultID, undefined, context);
    }
    static getAuthorizationServiceMismatch(context) {
        return new StorageError_1.default(403, "AuthorizationServiceMismatch", "This request is not authorized to perform this operation using this service.", context.contextID || defaultID, undefined, context);
    }
    static getAuthorizationResourceTypeMismatch(context) {
        return new StorageError_1.default(403, "AuthorizationResourceTypeMismatch", "This request is not authorized to perform this operation using this resource type.", context.contextID || defaultID, undefined, context);
    }
    static getAccountNameEmpty(context) {
        return new StorageError_1.default(400, "AccountNameEmpty", "The specified account name is empty.", context.contextID || defaultID, undefined, context);
    }
    static getTableNotExist(context) {
        return new StorageError_1.default(404, "TableNotFound", "The table specified does not exist.", context.contextID || defaultID, undefined, context);
    }
    static getAuthorizationFailure(context) {
        return new StorageError_1.default(403, "AuthorizationFailure", 
        // tslint:disable-next-line:max-line-length
        "Server failed to authenticate the request. Make sure the value of the Authorization header is formed correctly including the signature.", context.contextID || defaultID, undefined, context);
    }
    static getEntityAlreadyExist(context) {
        return new StorageError_1.default(409, "EntityAlreadyExists", "The specified entity already exists.", context.contextID || defaultID, undefined, context);
    }
    static getPropertiesNeedValue(context) {
        return new StorageError_1.default(400, "PropertiesNeedValue", "The values are not specified for all properties in the entity.", context.contextID || defaultID, undefined, context);
    }
    static getAtomFormatNotSupported(context) {
        return new StorageError_1.default(415, "AtomFormatNotSupported", "Atom format is not supported.", context.contextID || defaultID, undefined, context);
    }
    static getPreconditionFailed(context) {
        return new StorageError_1.default(412, "UpdateConditionNotSatisfied", "The update condition specified in the request was not satisfied.", context.contextID || defaultID, undefined, context);
    }
    static getTableNotFound(context) {
        return new StorageError_1.default(404, "TableNotFound", "The table specified does not exist.", context.contextID || defaultID, undefined, context);
    }
    static ResourceNotFound(context) {
        return new StorageError_1.default(404, "ResourceNotFound", "The specified resource does not exist.", context.contextID || defaultID, undefined, context);
    }
    static getEntityNotFound(context) {
        return new StorageError_1.default(404, "ResourceNotFound", "The specified resource does not exist.", context.contextID || defaultID, undefined, context);
    }
    static getQueryConditionInvalid(context) {
        return new StorageError_1.default(400, "InvalidInput", "The query condition specified in the request is invalid.", context.contextID || defaultID, undefined, context);
    }
    static getInvalidResourceName(context) {
        return new StorageError_1.default(400, "", `The specifed resource name contains invalid characters.`, context.contextID || defaultID, undefined, context);
    }
    static getOutOfRangeName(context) {
        return new StorageError_1.default(400, "", `The specified resource name length is not within the permissible limits.`, context.contextID || defaultID, undefined, context);
    }
    static getInvalidXmlDocument(context) {
        return new StorageError_1.default(400, "InvalidXmlDocument", `XML specified is not syntactically valid.`, context.contextID || defaultID, undefined, context);
    }
    static getInvalidQueryParameterValue(context, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidQueryParameterValue", `Value for one of the query parameters specified in the request URI is invalid.`, context.contextID || defaultID, additionalMessages, context);
    }
    static getInvalidCorsHeaderValue(context, additionalMessages) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "A required CORS header is not present.", context.contextID || defaultID, additionalMessages, context);
    }
    static corsPreflightFailure(context, additionalMessages) {
        return new StorageError_1.default(403, "CorsPreflightFailure", "CORS not enabled or no matching rule found for this request.", context.contextID || defaultID, additionalMessages, context);
    }
    static getInvalidAuthenticationInfo(context) {
        return new StorageError_1.default(400, "InvalidAuthenticationInfo", "Authentication information is not given in the correct format. Check the value of Authorization header.", context.contextID || defaultID, undefined, context);
    }
    static getAuthenticationFailed(context, authenticationErrorDetail) {
        return new StorageError_1.default(403, "AuthenticationFailed", "Server failed to authenticate the request. Make sure the value of the Authorization header is formed correctly including the signature.", context.contextID || defaultID, {
            AuthenticationErrorDetail: authenticationErrorDetail
        }, context);
    }
    static getNotImplementedError(context) {
        return new StorageError_1.default(501, "NotImplemented", "The requested operation is not implemented on the specified resource.", context.contextID || defaultID, undefined, context);
    }
    static getPropertyValueTooLargeError(context) {
        return new StorageError_1.default(400, "PropertyValueTooLarge", "The property value exceeds the maximum allowed size (64KB). If the property value is a string, it is UTF-16 encoded and the maximum number of characters should be 32K or less.", context.contextID || defaultID, undefined, context);
    }
    static getRequestBodyTooLarge(context) {
        return new StorageError_1.default(413, "RequestBodyTooLarge", `The request body is too large and exceeds the maximum permissible limit.`, context.contextID || defaultID, undefined, context);
    }
    static getEntityTooLarge(context) {
        return new StorageError_1.default(400, "EntityTooLarge", `The entity is larger than the maximum allowed size (1MB).`, context.contextID || defaultID, undefined, context);
    }
}
exports.default = StorageErrorFactory;
//# sourceMappingURL=StorageErrorFactory.js.map