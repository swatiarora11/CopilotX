"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ValueNode_1 = tslib_1.__importDefault(require("./ValueNode"));
/**
 * Represents a constant value which is stored in its underlying JavaScript representation.
 *
 * This is used to hold boolean, number, and string values that are provided in the query.
 * For example, the query `PartitionKey eq 'foo'` would contain a `ConstantNode` with the value `foo`.
 */
class BigNumberNode extends ValueNode_1.default {
    get name() {
        return "BigNumber";
    }
    compare(context, other) {
        const thisValue = this.evaluate(context);
        const otherValue = other.evaluate(context);
        if (thisValue === undefined || otherValue === undefined || otherValue === null) {
            return NaN;
        }
        if (thisValue.startsWith("-")) {
            // Compare two negative number
            if (otherValue.startsWith("-")) {
                return -(this.comparePositiveNumber(thisValue.substring(1), otherValue.substring(1)));
            }
            else {
                // Could be two 0s formated with -000 and 000
                if (this.trimZeros(thisValue.substring(1)).length === 0
                    && this.trimZeros(otherValue).length === 0) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
        }
        else {
            // Could be two 0s formated with -000 and 000
            if (otherValue.startsWith("-")) {
                if (this.trimZeros(thisValue.substring(1)).length === 0
                    && this.trimZeros(otherValue).length === 0) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else {
                return this.comparePositiveNumber(thisValue, otherValue);
            }
        }
    }
    comparePositiveNumber(thisValue, otherValue) {
        const thisNumberValue = this.trimZeros(thisValue);
        const otherNumberValue = this.trimZeros(otherValue);
        if (thisNumberValue.length < otherNumberValue.length) {
            return -1;
        }
        else if (thisNumberValue.length > otherNumberValue.length) {
            return 1;
        }
        let index = 0;
        while (index < thisNumberValue.length) {
            if (thisNumberValue[index] < otherNumberValue[index]) {
                return -1;
            }
            else if (thisNumberValue[index] > otherNumberValue[index]) {
                return 1;
            }
            ++index;
        }
        return 0;
    }
    trimZeros(numberString) {
        let index = 0;
        while (index < numberString.length) {
            if (numberString[index] === '0') {
                ++index;
            }
            else {
                break;
            }
        }
        return numberString.substring(index);
    }
}
exports.default = BigNumberNode;
//# sourceMappingURL=BigNumberNode.js.map