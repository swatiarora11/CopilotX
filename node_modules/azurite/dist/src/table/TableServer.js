"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http = tslib_1.__importStar(require("http"));
const https = tslib_1.__importStar(require("https"));
const AccountDataStore_1 = tslib_1.__importDefault(require("../common/AccountDataStore"));
const ConfigurationBase_1 = require("../common/ConfigurationBase");
const Logger_1 = tslib_1.__importDefault(require("../common/Logger"));
const LokiTableMetadataStore_1 = tslib_1.__importDefault(require("../table/persistence/LokiTableMetadataStore"));
const ServerBase_1 = tslib_1.__importStar(require("../common/ServerBase"));
const TableConfiguration_1 = tslib_1.__importDefault(require("./TableConfiguration"));
const TableRequestListenerFactory_1 = tslib_1.__importDefault(require("./TableRequestListenerFactory"));
/**
 * Default implementation of Azurite Table HTTP server.
 * This implementation provides a HTTP service based on express framework and LokiJS in memory database.
 *
 * We can create other table servers by extending abstract Server class and initialize different httpServer,
 * dataStore or requestListenerFactory fields.
 *
 * For example, creating a HTTPS server to accept HTTPS requests, or using other
 * Node.js HTTP frameworks like Koa, or just using another SQL database.
 *
 * @export
 * @class Server
 */
class TableServer extends ServerBase_1.default {
    constructor(configuration) {
        // If configuration is undefined, we'll use the default one
        if (configuration === undefined) {
            configuration = new TableConfiguration_1.default();
        }
        // Create a http server to accept table operation request
        let httpServer;
        const certOption = configuration.hasCert();
        switch (certOption) {
            case ConfigurationBase_1.CertOptions.PEM:
            case ConfigurationBase_1.CertOptions.PFX:
                httpServer = https.createServer(configuration.getCert(certOption));
                break;
            default:
                httpServer = http.createServer();
        }
        // Create **dataStore with Loki.js
        const metadataStore = new LokiTableMetadataStore_1.default(configuration.metadataDBPath, configuration.isMemoryPersistence);
        const accountDataStore = new AccountDataStore_1.default(Logger_1.default);
        // Here we use express request listener and register table handler
        const requestListenerFactory = new TableRequestListenerFactory_1.default(metadataStore, accountDataStore, configuration.enableAccessLog, // Access log includes every handled HTTP request
        configuration.accessLogWriteStream, configuration.skipApiVersionCheck, configuration.getOAuthLevel(), configuration.disableProductStyleUrl);
        const host = configuration.host;
        const port = configuration.port;
        super(host, port, httpServer, requestListenerFactory, configuration);
        this.metadataStore = metadataStore;
        this.accountDataStore = accountDataStore;
    }
    async clean() {
        if (this.getStatus() === ServerBase_1.ServerStatus.Closed) {
            if (this.metadataStore !== undefined) {
                await this.metadataStore.clean();
            }
            if (this.accountDataStore !== undefined) {
                await this.accountDataStore.clean();
            }
            return;
        }
        throw Error(`Cannot clean up table server in status ${this.getStatus()}.`);
    }
    async beforeStart() {
        const msg = `Azurite Table service is starting on ${this.host}:${this.port}`;
        Logger_1.default.info(msg);
        if (this.accountDataStore !== undefined) {
            await this.accountDataStore.init();
        }
        if (this.metadataStore !== undefined) {
            await this.metadataStore.init();
        }
    }
    async afterStart() {
        const msg = `Azurite Table service successfully listens on ${this.getHttpServerAddress()}`;
        Logger_1.default.info(msg);
    }
    async beforeClose() {
        const BEFORE_CLOSE_MESSAGE = `Azurite Table service is closing...`;
        Logger_1.default.info(BEFORE_CLOSE_MESSAGE);
    }
    async afterClose() {
        if (this.metadataStore !== undefined) {
            await this.metadataStore.close();
        }
        if (this.accountDataStore !== undefined) {
            await this.accountDataStore.close();
        }
        const AFTER_CLOSE_MESSAGE = `Azurite Table service successfully closed`;
        Logger_1.default.info(AFTER_CLOSE_MESSAGE);
    }
}
exports.default = TableServer;
//# sourceMappingURL=TableServer.js.map