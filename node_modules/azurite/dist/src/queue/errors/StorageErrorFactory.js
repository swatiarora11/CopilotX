"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const StorageError_1 = tslib_1.__importDefault(require("./StorageError"));
const defaultID = "DefaultID";
/**
 * A factory class maintains all Azure Storage queue service errors.
 *
 * @export
 * @class StorageErrorFactory
 */
class StorageErrorFactory {
    static notImplement(contextID = defaultID) {
        return new StorageError_1.default(500, "functionNotImplement", `No function.`, contextID);
    }
    static InternalError(contextID = defaultID) {
        return new StorageError_1.default(500, "InternalError", `The server encountered an internal error. Please retry the request.`, contextID);
    }
    static getInvalidHeaderValue(contextID = "", additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", contextID, additionalMessages);
    }
    static getInvalidAPIVersion(contextID = "", apiVersion) {
        return new StorageError_1.default(400, "InvalidHeaderValue", `The API version ${apiVersion} is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter \"--skipApiVersionCheck\" or Visual Studio Code configuration \"Skip Api Version Check\" can skip this error. `, contextID);
    }
    static getInvaidXmlDocument(contextID = defaultID) {
        return new StorageError_1.default(400, "InvaidXmlDocument", `XML specified is not syntactically valid.`, contextID);
    }
    static corsPreflightFailure(contextID = defaultID, additionalMessages) {
        return new StorageError_1.default(403, "CorsPreflightFailure", "CORS not enabled or no matching rule found for this request.", contextID, additionalMessages);
    }
    static getInvalidUri(contextID = defaultID, additionalMessages) {
        return new StorageError_1.default(400, "InvalidUri", "The specifed resource name contains invalid characters.", contextID);
    }
    static getInvalidAuthenticationInfo(contextID = defaultID) {
        return new StorageError_1.default(400, "InvalidAuthenticationInfo", "Authentication information is not given in the correct format. Check the value of Authorization header.", contextID);
    }
    static getAuthenticationFailed(contextID = defaultID, authenticationErrorDetail) {
        return new StorageError_1.default(403, "AuthenticationFailed", "Server failed to authenticate the request. Make sure the value of the Authorization header is formed correctly including the signature.", contextID, {
            AuthenticationErrorDetail: authenticationErrorDetail
        });
    }
    static getInvalidCorsHeaderValue(contextID = defaultID, additionalMessages) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "A required CORS header is not present.", contextID, additionalMessages);
    }
    static getAuthorizationFailure(contextID = defaultID) {
        return new StorageError_1.default(403, "AuthenticationFailed", "Server failed to authenticate the request." +
            "Make sure the value of the Authorization header is formed correctly including the signature.", contextID);
    }
    static getInvalidOperation(contextID, message = "") {
        return new StorageError_1.default(400, "InvalidOperation", message, contextID);
    }
    static ResourceNotFound(contextID) {
        return new StorageError_1.default(404, "ResourceNotFound", "The specified resource does not exist.", contextID);
    }
    static getAuthorizationSourceIPMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationSourceIPMismatch", "This request is not authorized to perform this operation using this source IP {SourceIP}.", contextID);
    }
    static getAuthorizationProtocolMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationProtocolMismatch", "This request is not authorized to perform this operation using this protocol.", contextID);
    }
    static getAuthorizationPermissionMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationPermissionMismatch", "This request is not authorized to perform this operation using this permission.", contextID);
    }
    static getAuthorizationServiceMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationServiceMismatch", "This request is not authorized to perform this operation using this service.", contextID);
    }
    static getAuthorizationResourceTypeMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationResourceTypeMismatch", "This request is not authorized to perform this operation using this resource type.", contextID);
    }
    static getInvalidXmlDocument(contextID = defaultID, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidXmlDocument", `XML specified is not syntactically valid.`, contextID, additionalMessages);
    }
    static getInvalidQueryParameterValue(contextID = defaultID, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidQueryParameterValue", `Value for one of the query parameters specified in the request URI is invalid.`, contextID, additionalMessages);
    }
    static getOutOfRangeQueryParameterValue(contextID = defaultID, additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "OutOfRangeQueryParameterValue", `One of the query parameters specified in the request URI is outside the permissible range.`, contextID, additionalMessages);
    }
    static getRequestBodyTooLarge(contextID = defaultID, additionalMessages) {
        return new StorageError_1.default(413, "RequestBodyTooLarge", `The request body is too large and exceeds the maximum permissible limit.`, contextID, additionalMessages);
    }
    static getMessageTooLarge(contextID = defaultID) {
        return new StorageError_1.default(400, "MessageTooLarge", `The message exceeds the maximum allowed size.`, contextID);
    }
    static getPopReceiptMismatch(contextID = defaultID) {
        return new StorageError_1.default(400, "PopReceiptMismatch", `The specified pop receipt did not match the pop receipt for a dequeued message.`, contextID);
    }
    static getMessageNotFound(contextID = defaultID) {
        return new StorageError_1.default(404, "MessageNotFound", `The specified message does not exist.`, contextID);
    }
    static getInvalidResourceName(contextID = defaultID) {
        return new StorageError_1.default(400, "InvalidResourceName", `The specifed resource name contains invalid characters.`, contextID);
    }
    static getOutOfRangeName(contextID = defaultID) {
        return new StorageError_1.default(400, "OutOfRangeInput", `The specified resource name length is not within the permissible limits.`, contextID);
    }
    static getQueueAlreadyExists(contextID = defaultID) {
        return new StorageError_1.default(409, "QueueAlreadyExists", "The specified queue already exists.", contextID);
    }
    static getQueueNotFound(contextID = defaultID) {
        return new StorageError_1.default(404, "QueueNotFound", "The specified queue does not exist.", contextID);
    }
}
exports.default = StorageErrorFactory;
//# sourceMappingURL=StorageErrorFactory.js.map