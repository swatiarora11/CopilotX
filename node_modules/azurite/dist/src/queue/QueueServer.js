"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http = tslib_1.__importStar(require("http"));
const https = tslib_1.__importStar(require("https"));
const AccountDataStore_1 = tslib_1.__importDefault(require("../common/AccountDataStore"));
const ConfigurationBase_1 = require("../common/ConfigurationBase");
const Logger_1 = tslib_1.__importDefault(require("../common/Logger"));
const FSExtentStore_1 = tslib_1.__importDefault(require("../common/persistence/FSExtentStore"));
const MemoryExtentStore_1 = tslib_1.__importStar(require("../common/persistence/MemoryExtentStore"));
const LokiExtentMetadataStore_1 = tslib_1.__importDefault(require("../common/persistence/LokiExtentMetadataStore"));
const ServerBase_1 = tslib_1.__importStar(require("../common/ServerBase"));
const QueueGCManager_1 = tslib_1.__importDefault(require("./gc/QueueGCManager"));
const LokiQueueMetadataStore_1 = tslib_1.__importDefault(require("./persistence/LokiQueueMetadataStore"));
const QueueConfiguration_1 = tslib_1.__importDefault(require("./QueueConfiguration"));
const QueueRequestListenerFactory_1 = tslib_1.__importDefault(require("./QueueRequestListenerFactory"));
const StorageError_1 = tslib_1.__importDefault(require("./errors/StorageError"));
const BEFORE_CLOSE_MESSAGE = `Azurite Queue service is closing...`;
const BEFORE_CLOSE_MESSAGE_GC_ERROR = `Azurite Queue service is closing... Critical error happens during GC.`;
const AFTER_CLOSE_MESSAGE = `Azurite Queue service successfully closed`;
/**
 * Default implementation of Azurite Blob HTTP server.
 * This implementation provides a HTTP service based on express framework and LokiJS in memory database.
 *
 * We can create other blob servers by extending abstract Server class and initialize different httpServer,
 * dataStore or requestListenerFactory fields.
 *
 * For example, creating a HTTPS server to accept HTTPS requests, or using other
 * Node.js HTTP frameworks like Koa, or just using another SQL database.
 *
 * @export
 * @class Server
 */
class QueueServer extends ServerBase_1.default {
    /**
     * Creates an instance of Server.
     *
     * @param {BlobConfiguration} configuration
     * @memberof Server
     */
    constructor(configuration) {
        if (configuration === undefined) {
            configuration = new QueueConfiguration_1.default();
        }
        const host = configuration.host;
        const port = configuration.port;
        // We can create a HTTP server or a HTTPS server here
        let httpServer;
        const certOption = configuration.hasCert();
        switch (certOption) {
            case ConfigurationBase_1.CertOptions.PEM:
            case ConfigurationBase_1.CertOptions.PFX:
                httpServer = https.createServer(configuration.getCert(certOption));
                break;
            default:
                httpServer = http.createServer();
        }
        // We can change the persistency layer implementation by
        // creating a new XXXDataStore class implementing IBlobDataStore interface
        // and replace the default LokiBlobDataStore
        const metadataStore = new LokiQueueMetadataStore_1.default(configuration.metadataDBPath, configuration.isMemoryPersistence);
        const extentMetadataStore = new LokiExtentMetadataStore_1.default(configuration.extentDBPath, configuration.isMemoryPersistence);
        const extentStore = configuration.isMemoryPersistence ? new MemoryExtentStore_1.default("queue", configuration.memoryStore ?? MemoryExtentStore_1.SharedChunkStore, extentMetadataStore, Logger_1.default, (sc, er, em, ri) => new StorageError_1.default(sc, er, em, ri)) : new FSExtentStore_1.default(extentMetadataStore, configuration.persistencePathArray, Logger_1.default);
        const accountDataStore = new AccountDataStore_1.default(Logger_1.default);
        // We can also change the HTTP framework here by
        // creating a new XXXListenerFactory implementing IRequestListenerFactory interface
        // and replace the default Express based request listener
        const requestListenerFactory = new QueueRequestListenerFactory_1.default(metadataStore, extentStore, accountDataStore, configuration.enableAccessLog, // Access log includes every handled HTTP request
        configuration.accessLogWriteStream, configuration.skipApiVersionCheck, configuration.getOAuthLevel(), configuration.disableProductStyleUrl);
        super(host, port, httpServer, requestListenerFactory, configuration);
        const gcManager = new QueueGCManager_1.default(metadataStore, extentMetadataStore, extentStore, () => {
            // tslint:disable-next-line:no-console
            console.log(BEFORE_CLOSE_MESSAGE_GC_ERROR);
            Logger_1.default.info(BEFORE_CLOSE_MESSAGE_GC_ERROR);
            this.close().then(() => {
                // tslint:disable-next-line:no-console
                console.log(AFTER_CLOSE_MESSAGE);
                Logger_1.default.info(AFTER_CLOSE_MESSAGE);
            });
        }, Logger_1.default);
        this.metadataStore = metadataStore;
        this.extentMetadataStore = extentMetadataStore;
        this.extentStore = extentStore;
        this.accountDataStore = accountDataStore;
        this.gcManager = gcManager;
    }
    /**
     * Clean up server persisted data, including Loki metadata database file,
     * Loki extent database file and extent data.
     *
     * @returns {Promise<void>}
     * @memberof BlobServer
     */
    async clean() {
        if (this.getStatus() === ServerBase_1.ServerStatus.Closed) {
            if (this.extentStore !== undefined) {
                await this.extentStore.clean();
            }
            if (this.extentMetadataStore !== undefined) {
                await this.extentMetadataStore.clean();
            }
            if (this.metadataStore !== undefined) {
                await this.metadataStore.clean();
            }
            if (this.accountDataStore !== undefined) {
                await this.accountDataStore.clean();
            }
            return;
        }
        throw Error(`Cannot clean up queue server in status ${this.getStatus()}.`);
    }
    async beforeStart() {
        const msg = `Azurite Queue service is starting on ${this.host}:${this.port}`;
        Logger_1.default.info(msg);
        if (this.accountDataStore !== undefined) {
            await this.accountDataStore.init();
        }
        if (this.metadataStore !== undefined) {
            await this.metadataStore.init();
        }
        if (this.metadataStore !== undefined) {
            await this.extentMetadataStore.init();
        }
        if (this.extentStore !== undefined) {
            await this.extentStore.init();
        }
        if (this.gcManager !== undefined) {
            await this.gcManager.start();
        }
    }
    async afterStart() {
        const msg = `Azurite Queue service successfully listens on ${this.getHttpServerAddress()}`;
        Logger_1.default.info(msg);
    }
    async beforeClose() {
        Logger_1.default.info(BEFORE_CLOSE_MESSAGE);
    }
    async afterClose() {
        if (this.gcManager !== undefined) {
            await this.gcManager.close();
        }
        if (this.extentStore !== undefined) {
            await this.extentStore.close();
        }
        if (this.extentMetadataStore !== undefined) {
            await this.extentMetadataStore.close();
        }
        if (this.metadataStore !== undefined) {
            await this.metadataStore.close();
        }
        if (this.accountDataStore !== undefined) {
            await this.accountDataStore.close();
        }
        Logger_1.default.info(AFTER_CLOSE_MESSAGE);
    }
}
exports.default = QueueServer;
//# sourceMappingURL=QueueServer.js.map