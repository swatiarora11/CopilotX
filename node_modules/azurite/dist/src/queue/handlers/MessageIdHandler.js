"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QueueStorageContext_1 = tslib_1.__importDefault(require("../context/QueueStorageContext"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const constants_1 = require("../utils/constants");
const utils_1 = require("../utils/utils");
const BaseHandler_1 = tslib_1.__importDefault(require("./BaseHandler"));
/**
 * MessageIdHandler handles Azure Storage a given message related requests.
 *
 * @export
 * @class MessageIdHandler
 * @implements {IMessageIdHandler}
 */
class MessageIdHandler extends BaseHandler_1.default {
    /**
     * Update a message.
     *
     * @param {Models.QueueMessage} queueMessage
     * @param {string} popReceipt
     * @param {number} visibilitytimeout
     * @param {Models.MessageIdUpdateOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.MessageIdUpdateResponse>}
     * @memberof MessageIdHandler
     */
    async update(queueMessage, popReceipt, visibilitytimeout, options, context) {
        const queueCtx = new QueueStorageContext_1.default(context);
        const accountName = queueCtx.account;
        const queueName = queueCtx.queue;
        const messageId = queueCtx.messageId;
        // TODO: Similar to enqueue, deserialize does not support the message text with only empty character.
        // If the text is undefined, try to retrive it from the XML body here.
        if (queueMessage.messageText === undefined) {
            const body = queueCtx.request.getBody();
            const parsedBody = await (0, utils_1.parseXMLwithEmpty)(body || "");
            for (const text in parsedBody) {
                if (Object.hasOwnProperty.bind(parsedBody)(text) &&
                    text.toLowerCase() === "messagetext") {
                    queueMessage.messageText = parsedBody[text];
                    break;
                }
            }
        }
        // Check if the text is out of range.
        if (queueMessage.messageText !== undefined &&
            (0, utils_1.getUTF8ByteSize)(queueMessage.messageText) > constants_1.MESSAGETEXT_LENGTH_MAX) {
            throw StorageErrorFactory_1.default.getRequestBodyTooLarge(queueCtx.contextID, {
                MaxLimit: "65536"
            });
        }
        const newPopReceipt = (0, utils_1.getPopReceipt)(context.startTime);
        // Validate the query parameters.
        const timeNextVisible = new Date(context.startTime.getTime() + constants_1.DEFAULT_UPDATE_VISIBILITYTIMEOUT * 1000 // 30s as default
        );
        if (visibilitytimeout !== undefined) {
            if (visibilitytimeout < constants_1.UPDATE_VISIBILITYTIMEOUT_MIN ||
                visibilitytimeout > constants_1.UPDATE_VISIBILITYTIMEOUT_MAX) {
                throw StorageErrorFactory_1.default.getOutOfRangeQueryParameterValue(context.contextID, {
                    QueryParameterName: "visibilitytimeout",
                    QueryParameterValue: `${visibilitytimeout}`,
                    MinimumAllowed: `${constants_1.UPDATE_VISIBILITYTIMEOUT_MIN}`,
                    MaximumAllowed: `${constants_1.UPDATE_VISIBILITYTIMEOUT_MAX}`
                });
            }
            timeNextVisible.setTime(context.startTime.getTime() + visibilitytimeout * 1000);
        }
        // Initial the persistency with undefined, denoting no text change.
        const message = {
            accountName,
            queueName,
            messageId,
            popReceipt: newPopReceipt,
            timeNextVisible,
            persistency: undefined
        };
        // If the given message text is valid, then the stored text should be updated if the popReceipt is correct.
        // The data will be first write to extent,
        // then the popRecept should be check in metadata store to determine update or not.
        if (queueMessage.messageText !== undefined) {
            message.persistency = await this.extentStore.appendExtent(Buffer.from(queueMessage.messageText), context.contextID);
        }
        await this.metadataStore.updateMessage(message, popReceipt, context);
        const response = {
            popReceipt: newPopReceipt,
            timeNextVisible,
            date: context.startTime,
            requestId: context.contextID,
            version: constants_1.QUEUE_API_VERSION,
            statusCode: 204,
            clientRequestId: options.requestId
        };
        return response;
    }
    /**
     * Delete a message.
     *
     * @param {string} popReceipt
     * @param {Models.MessageIdDeleteMethodOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.MessageIdDeleteResponse>}
     * @memberof MessageIdHandler
     */
    async delete(popReceipt, options, context) {
        const queueCtx = new QueueStorageContext_1.default(context);
        const accountName = queueCtx.account;
        const queueName = queueCtx.queue;
        const messageId = queueCtx.messageId;
        await this.metadataStore.deleteMessage(accountName, queueName, messageId, popReceipt, context);
        const response = {
            date: context.startTime,
            requestId: context.contextID,
            version: constants_1.QUEUE_API_VERSION,
            statusCode: 204,
            clientRequestId: options.requestId
        };
        return response;
    }
}
exports.default = MessageIdHandler;
//# sourceMappingURL=MessageIdHandler.js.map