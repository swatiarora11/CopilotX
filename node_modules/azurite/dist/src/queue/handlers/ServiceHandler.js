"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QueueStorageContext_1 = tslib_1.__importDefault(require("../context/QueueStorageContext"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const Models = tslib_1.__importStar(require("../generated/artifacts/models"));
const xml_1 = require("../generated/utils/xml");
const constants_1 = require("../utils/constants");
const BaseHandler_1 = tslib_1.__importDefault(require("./BaseHandler"));
/**
 * ServiceHandler handles Azure Storage queue service related requests.
 *
 * @export
 * @class ServiceHandler
 * @implements {IHandler}
 */
class ServiceHandler extends BaseHandler_1.default {
    constructor() {
        super(...arguments);
        /**
         * Default listing queues max number.
         *
         * @private
         * @memberof ServiceHandler
         */
        this.LIST_QUEUES_MAX_RESULTS_DEFAULT = 5000;
        /**
         * Default service properties.
         *
         * @private
         * @memberof ServiceHandler
         */
        this.defaultServiceProperties = {
            cors: [],
            defaultServiceVersion: constants_1.QUEUE_API_VERSION,
            hourMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            },
            logging: {
                deleteProperty: true,
                read: true,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0",
                write: true
            },
            minuteMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            },
            staticWebsite: {
                enabled: false
            }
        };
    }
    /**
     * Set blob service properties.
     *
     * @param {Models.StorageServiceProperties} storageServiceProperties
     * @param {Models.ServiceSetPropertiesOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceSetPropertiesResponse>}
     * @memberof ServiceHandler
     */
    async setProperties(storageServiceProperties, options, context) {
        const queueCtx = new QueueStorageContext_1.default(context);
        const accountName = queueCtx.account;
        // TODO: deserializor has a bug that when cors is undefined,
        // it will serialize it to empty array instead of undefined
        const body = queueCtx.request.getBody();
        const parsedBody = await (0, xml_1.parseXML)(body || "");
        if (!Object.hasOwnProperty.bind(parsedBody)('cors') &&
            !Object.hasOwnProperty.bind(parsedBody)('Cors')) {
            storageServiceProperties.cors = undefined;
        }
        // Azure Storage allows allowedHeaders and exposedHeaders to be empty,
        // Azurite will set to empty string for this scenario
        for (const cors of storageServiceProperties.cors || []) {
            cors.allowedHeaders = cors.allowedHeaders || "";
            cors.exposedHeaders = cors.exposedHeaders || "";
        }
        await this.metadataStore.updateServiceProperties({
            ...storageServiceProperties,
            accountName
        });
        const response = {
            requestId: context.contextID,
            statusCode: 202,
            version: constants_1.QUEUE_API_VERSION,
            clientRequestId: options.requestId
        };
        return response;
    }
    /**
     * Get queue service properties.
     *
     * @param {Models.ServiceGetPropertiesOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceGetPropertiesResponse>}
     * @memberof ServiceHandler
     */
    async getProperties(options, context) {
        const queueCtx = new QueueStorageContext_1.default(context);
        const accountName = queueCtx.account;
        let properties = await this.metadataStore.getServiceProperties(accountName);
        if (!properties) {
            properties = { ...this.defaultServiceProperties, accountName };
        }
        if (properties.cors === undefined) {
            properties.cors = [];
        }
        if (properties.hourMetrics === undefined) {
            properties.hourMetrics = this.defaultServiceProperties.hourMetrics;
        }
        if (properties.logging === undefined) {
            properties.logging = this.defaultServiceProperties.logging;
        }
        if (properties.minuteMetrics === undefined) {
            properties.minuteMetrics = this.defaultServiceProperties.minuteMetrics;
        }
        const response = {
            ...properties,
            requestId: context.contextID,
            statusCode: 200,
            version: constants_1.QUEUE_API_VERSION,
            clientRequestId: options.requestId
        };
        return response;
    }
    async getStatistics(options, context) {
        if (!context.context.isSecondary) {
            throw StorageErrorFactory_1.default.getInvalidQueryParameterValue(context.contextID);
        }
        const response = {
            statusCode: 200,
            requestId: context.contextID,
            version: constants_1.QUEUE_API_VERSION,
            date: context.startTime,
            geoReplication: {
                status: Models.GeoReplicationStatusType.Live,
                lastSyncTime: context.startTime
            },
            clientRequestId: options.requestId
        };
        return response;
    }
    /**
     * List queues.
     *
     * @param {Models.ServiceListQueuesSegmentOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceListQueuesSegmentResponse>}
     * @memberof ServiceHandler
     */
    async listQueuesSegment(options, context) {
        const queueCtx = new QueueStorageContext_1.default(context);
        const request = queueCtx.request;
        const accountName = queueCtx.account;
        let maxresults = this.LIST_QUEUES_MAX_RESULTS_DEFAULT;
        if (options.maxresults !== undefined) {
            if (options.maxresults < constants_1.LIST_QUEUE_MAXRESSULTS_MIN ||
                options.maxresults > constants_1.LIST_QUEUE_MAXRESSULTS_MAX) {
                throw StorageErrorFactory_1.default.getOutOfRangeQueryParameterValue(context.contextID, {
                    QueryParameterName: "maxresults",
                    QueryParameterValue: `${options.maxresults}`,
                    MinimumAllowed: `${constants_1.LIST_QUEUE_MAXRESSULTS_MIN}`,
                    MaximumAllowed: `${constants_1.LIST_QUEUE_MAXRESSULTS_MAX}`
                });
            }
            maxresults = options.maxresults;
        }
        options.prefix = options.prefix || "";
        const marker = parseInt(options.marker || "0", 10);
        const queues = await this.metadataStore.listQueues(accountName, options.prefix, maxresults, marker);
        // Only the query parameter "include" contains the value "metadata" can the result present the metadata.
        let includeMetadata = false;
        if (options.include) {
            for (const item of options.include) {
                if (item.toLowerCase() === "metadata") {
                    includeMetadata = true;
                    break;
                }
            }
        }
        if (!includeMetadata) {
            for (const queue of queues[0]) {
                queue.metadata = undefined;
            }
        }
        const serviceEndpoint = `${request.getEndpoint()}/${accountName}`;
        const res = {
            queueItems: queues[0],
            maxResults: maxresults,
            nextMarker: `${queues[1] || ""}`,
            prefix: options.prefix,
            serviceEndpoint,
            statusCode: 200,
            requestId: context.contextID,
            version: constants_1.QUEUE_API_VERSION,
            clientRequestId: options.requestId
        };
        return res;
    }
}
exports.default = ServiceHandler;
//# sourceMappingURL=ServiceHandler.js.map