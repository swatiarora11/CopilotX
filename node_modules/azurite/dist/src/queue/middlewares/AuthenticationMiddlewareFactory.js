"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const QueueStorageContext_1 = tslib_1.__importDefault(require("../context/QueueStorageContext"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const ExpressRequestAdapter_1 = tslib_1.__importDefault(require("../generated/ExpressRequestAdapter"));
const constants_1 = require("../utils/constants");
// TODO: Extract and move this part to common
class AuthenticationMiddlewareFactory {
    constructor(logger) {
        this.logger = logger;
    }
    createAuthenticationMiddleware(authenticators) {
        return (req, res, next) => {
            const context = new QueueStorageContext_1.default(res.locals, constants_1.DEFAULT_QUEUE_CONTEXT_PATH);
            this.authenticate(req, res, authenticators)
                .then(pass => {
                // TODO: To support public access, we need to modify here to reject request later in handler
                if (pass) {
                    next();
                }
                else {
                    next(StorageErrorFactory_1.default.getAuthorizationFailure(context.contextID));
                }
            })
                .catch(next);
        };
    }
    async authenticate(req, res, authenticators) {
        const request = new ExpressRequestAdapter_1.default(req);
        const context = new QueueStorageContext_1.default(res.locals, constants_1.DEFAULT_QUEUE_CONTEXT_PATH);
        this.logger.verbose(`AuthenticationMiddlewareFactory:createAuthenticationMiddleware() Validating authentications.`, context.contextID);
        let pass = false;
        for (const authenticator of authenticators) {
            pass = await authenticator.validate(request, context);
            if (pass === true) {
                return true;
            }
        }
        return false;
    }
}
exports.default = AuthenticationMiddlewareFactory;
//# sourceMappingURL=AuthenticationMiddlewareFactory.js.map