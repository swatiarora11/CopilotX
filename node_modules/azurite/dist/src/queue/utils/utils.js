"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseXMLwithEmpty = exports.getUTF8ByteSize = exports.readStreamToString = exports.getPopReceipt = exports.randomValueHex = exports.nameValidateCode = exports.isValidName = exports.deserializeRangeHeader = exports.checkApiVersion = void 0;
const tslib_1 = require("tslib");
const crypto_1 = require("crypto");
const xml2js = tslib_1.__importStar(require("xml2js"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
function checkApiVersion(inputApiVersion, validApiVersions, requestId) {
    if (!validApiVersions.includes(inputApiVersion)) {
        throw StorageErrorFactory_1.default.getInvalidAPIVersion(requestId, inputApiVersion);
    }
}
exports.checkApiVersion = checkApiVersion;
/**
 * Default range value [0, Infinite] will be returned if all parameters not provided.
 *
 * @export
 * @param {string} [rangeHeaderValue]
 * @param {string} [xMsRangeHeaderValue]
 * @returns {[number, number]}
 */
function deserializeRangeHeader(rangeHeaderValue, xMsRangeHeaderValue) {
    const range = xMsRangeHeaderValue || rangeHeaderValue;
    if (!range) {
        return [0, Infinity];
    }
    let parts = range.split("=");
    if (parts === undefined || parts.length !== 2) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    parts = parts[1].split("-");
    if (parts === undefined || parts.length < 1 || parts.length > 2) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    const startInclusive = parseInt(parts[0], 10);
    let endInclusive = Infinity;
    if (parts.length > 1 && parts[1] !== "") {
        endInclusive = parseInt(parts[1], 10);
    }
    if (startInclusive > endInclusive) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    return [startInclusive, endInclusive];
}
exports.deserializeRangeHeader = deserializeRangeHeader;
/**
 * Deserialize range header into valid page ranges.
 * For example, "bytes=0-1023" will return [0, 1023].
 *
 * Default range value [0, Infinite] will be returned if all parameters not provided.
 *
 * @private
 * @param {string} [rangeHeaderValue]
 * @param {string} [xMsRangeHeaderValue]
 * @returns {([number, number] | undefined)}
 */
/**
 * validate the input name for queue or container.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-queues-and-metadata
 *
 * @export
 * @param {string} name
 * @returns {nameValidateCode} //0 for valid, 1 for outOfRange, 2 for invalid.
 */
function isValidName(name) {
    if (name === "") {
        return nameValidateCode.invalidName;
    }
    if (name.length < 3 || name.length > 63) {
        return nameValidateCode.outOfRange;
    }
    if (name.split("-").indexOf("") !== -1) {
        return nameValidateCode.invalidName;
    }
    const reg = new RegExp("^[0-9|a-z|-]*$");
    if (reg.test(name)) {
        return nameValidateCode.valid;
    }
    return nameValidateCode.invalidName;
}
exports.isValidName = isValidName;
// The code to indicate the validation result.
var nameValidateCode;
(function (nameValidateCode) {
    nameValidateCode[nameValidateCode["valid"] = 0] = "valid";
    nameValidateCode[nameValidateCode["outOfRange"] = 1] = "outOfRange";
    nameValidateCode[nameValidateCode["invalidUri"] = 2] = "invalidUri";
    nameValidateCode[nameValidateCode["invalidName"] = 3] = "invalidName";
})(nameValidateCode || (exports.nameValidateCode = nameValidateCode = {}));
/**
 * Generate a random code with given length
 *
 * @public
 * @param {number} len
 * @returns {string}
 * @memberof LokiQueueDataStore
 */
function randomValueHex(len) {
    return (0, crypto_1.randomBytes)(Math.ceil(len / 2))
        .toString("hex") // convert to hexadecimal format
        .slice(0, len); // return required number of characters
}
exports.randomValueHex = randomValueHex;
/**
 * Generate the popreceipt for a get messages request.
 *
 * @public
 * @param {Date} requestDate
 * @returns {string}
 * @memberof LokiQueueDataStore
 */
function getPopReceipt(requestDate) {
    const encodedStr = requestDate
        .toUTCString()
        .split(" ")
        .slice(1, 5)
        .join("") + randomValueHex(4);
    return Buffer.from(encodedStr).toString("base64");
}
exports.getPopReceipt = getPopReceipt;
/**
 * Read the text from a readStream to a string.
 *
 * @export
 * @param {NodeJS.ReadableStream} data
 * @returns {Promise<string>}
 */
async function readStreamToString(data) {
    return new Promise((resolve, reject) => {
        let res = "";
        data
            .on("readable", () => {
            let chunk;
            chunk = data.read();
            if (chunk) {
                res += chunk.toString();
            }
        })
            .on("end", () => {
            resolve(res);
        })
            .on("error", reject);
    });
}
exports.readStreamToString = readStreamToString;
/**
 * Get the byte size of a string in UTF8.
 *
 * @public
 * @param {Date} requestDate
 * @returns {string}
 * @memberof LokiQueueDataStore
 */
function getUTF8ByteSize(text) {
    return Buffer.from(text, "utf8").length;
}
exports.getUTF8ByteSize = getUTF8ByteSize;
/**
 * Retrive the value from XML body without ignoring the empty characters.
 *
 * @export
 * @param {string} param
 * @param {boolean} [explicitChildrenWithOrder=false]
 * @returns {Promise<any>}
 */
function parseXMLwithEmpty(param, explicitChildrenWithOrder = false) {
    const xmlParser = new xml2js.Parser({
        explicitArray: false,
        explicitCharkey: false,
        explicitRoot: false,
        preserveChildrenOrder: explicitChildrenWithOrder,
        explicitChildren: explicitChildrenWithOrder
    });
    return new Promise((resolve, reject) => {
        xmlParser.parseString(param, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        });
    });
}
exports.parseXMLwithEmpty = parseXMLwithEmpty;
//# sourceMappingURL=utils.js.map