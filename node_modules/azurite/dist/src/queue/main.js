#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const Logger = tslib_1.__importStar(require("../common/Logger"));
const QueueConfiguration_1 = tslib_1.__importDefault(require("./QueueConfiguration"));
const QueueEnvironment_1 = tslib_1.__importDefault(require("./QueueEnvironment"));
const QueueServer_1 = tslib_1.__importDefault(require("./QueueServer"));
const constants_1 = require("./utils/constants");
const ConfigurationBase_1 = require("../common/ConfigurationBase");
// tslint:disable:no-console
function shutdown(server) {
    const beforeCloseMessage = `Azurite Queue service is closing...`;
    const afterCloseMessage = `Azurite Queue service successfully closed`;
    console.log(beforeCloseMessage);
    server.close().then(() => {
        console.log(afterCloseMessage);
    });
}
/**
 * Entry for Azurite queue service.
 */
async function main() {
    // Initialize and validate environment values from command line parameters
    const env = new QueueEnvironment_1.default();
    const location = await env.location();
    await (0, fs_extra_1.ensureDir)(location);
    await (0, fs_extra_1.access)(location);
    const debugFilePath = await env.debug();
    if (debugFilePath !== undefined) {
        await (0, fs_extra_1.ensureDir)((0, path_1.dirname)(debugFilePath));
        await (0, fs_extra_1.access)((0, path_1.dirname)(debugFilePath));
    }
    // Initialize server configuration
    // TODO: Should provide the absolute path directly.
    constants_1.DEFAULT_QUEUE_PERSISTENCE_ARRAY[0].locationPath = (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_PERSISTENCE_PATH);
    const config = new QueueConfiguration_1.default(env.queueHost(), env.queuePort(), (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_LOKI_DB_PATH), (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_EXTENT_LOKI_DB_PATH), constants_1.DEFAULT_QUEUE_PERSISTENCE_ARRAY, !env.silent(), undefined, (await env.debug()) !== undefined, await env.debug(), env.loose(), env.skipApiVersionCheck(), env.cert(), env.key(), env.pwd(), env.oauth(), env.disableProductStyleUrl(), env.inMemoryPersistence());
    // We use logger singleton as global debugger logger to track detailed outputs cross layers
    // Note that, debug log is different from access log which is only available in request handler layer to
    // track every request. Access log is not singleton, and initialized in specific RequestHandlerFactory implementations
    // Enable debug log by default before first release for debugging purpose
    Logger.configLogger(config.enableDebugLog, config.debugLogFilePath);
    // Create server instance
    const server = new QueueServer_1.default(config);
    (0, ConfigurationBase_1.setExtentMemoryLimit)(env, true);
    // Start server
    console.log(`Azurite Queue service is starting on ${config.host}:${config.port}`);
    await server.start();
    console.log(`Azurite Queue service successfully listens on ${server.getHttpServerAddress()}`);
    // Handle close event
    process
        .once("message", (msg) => {
        if (msg === "shutdown") {
            shutdown(server);
        }
    })
        .once("SIGINT", () => shutdown(server))
        .once("SIGTERM", () => shutdown(server));
}
main().catch((err) => {
    console.error(`Exit due to unhandled error: ${err.message}`);
    process.exit(1);
});
//# sourceMappingURL=main.js.map