"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const sequelize_1 = require("sequelize");
const v4_1 = tslib_1.__importDefault(require("uuid/v4"));
const constants_1 = require("../../common/utils/constants");
const utils_1 = require("../../common/utils/utils");
const utils_2 = require("../../common/utils/utils");
const ReadConditionalHeadersValidator_1 = require("../conditions/ReadConditionalHeadersValidator");
const WriteConditionalHeadersValidator_1 = require("../conditions/WriteConditionalHeadersValidator");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const Models = tslib_1.__importStar(require("../generated/artifacts/models"));
const BlobLeaseAdapter_1 = tslib_1.__importDefault(require("../lease/BlobLeaseAdapter"));
const BlobLeaseSyncer_1 = tslib_1.__importDefault(require("../lease/BlobLeaseSyncer"));
const BlobReadLeaseValidator_1 = tslib_1.__importDefault(require("../lease/BlobReadLeaseValidator"));
const BlobWriteLeaseSyncer_1 = tslib_1.__importDefault(require("../lease/BlobWriteLeaseSyncer"));
const BlobWriteLeaseValidator_1 = tslib_1.__importDefault(require("../lease/BlobWriteLeaseValidator"));
const ContainerDeleteLeaseValidator_1 = tslib_1.__importDefault(require("../lease/ContainerDeleteLeaseValidator"));
const ContainerLeaseAdapter_1 = tslib_1.__importDefault(require("../lease/ContainerLeaseAdapter"));
const ContainerLeaseSyncer_1 = tslib_1.__importDefault(require("../lease/ContainerLeaseSyncer"));
const ContainerReadLeaseValidator_1 = tslib_1.__importDefault(require("../lease/ContainerReadLeaseValidator"));
const LeaseFactory_1 = tslib_1.__importDefault(require("../lease/LeaseFactory"));
const constants_2 = require("../utils/constants");
const BlobReferredExtentsAsyncIterator_1 = tslib_1.__importDefault(require("./BlobReferredExtentsAsyncIterator"));
const PageWithDelimiter_1 = tslib_1.__importDefault(require("./PageWithDelimiter"));
const utils_3 = require("../utils/utils");
// tslint:disable: max-classes-per-file
class ServicesModel extends sequelize_1.Model {
}
class ContainersModel extends sequelize_1.Model {
}
class BlobsModel extends sequelize_1.Model {
}
class BlocksModel extends sequelize_1.Model {
}
/**
 * A SQL based Blob metadata storage implementation based on Sequelize.
 * Refer to CONTRIBUTION.md for how to setup SQL database environment.
 *
 * @export
 * @class SqlBlobMetadataStore
 * @implements {IBlobMetadataStore}
 */
class SqlBlobMetadataStore {
    /**
     * Creates an instance of SqlBlobMetadataStore.
     *
     * @param {string} connectionURI For example, "postgres://user:pass@example.com:5432/dbname"
     * @param {SequelizeOptions} [sequelizeOptions]
     * @memberof SqlBlobMetadataStore
     */
    constructor(connectionURI, sequelizeOptions) {
        this.initialized = false;
        this.closed = false;
        // Enable encrypt connection for SQL Server
        if (connectionURI.startsWith("mssql") && sequelizeOptions) {
            sequelizeOptions.dialectOptions = sequelizeOptions.dialectOptions || {};
            sequelizeOptions.dialectOptions.options =
                sequelizeOptions.dialectOptions.options || {};
            sequelizeOptions.dialectOptions.options.encrypt = true;
        }
        this.sequelize = new sequelize_1.Sequelize(connectionURI, sequelizeOptions);
    }
    async init() {
        await this.sequelize.authenticate();
        ServicesModel.init({
            accountName: {
                type: "VARCHAR(32)",
                primaryKey: true
            },
            defaultServiceVersion: {
                type: "VARCHAR(10)"
            },
            cors: {
                type: "VARCHAR(4095)"
            },
            logging: {
                type: "VARCHAR(255)"
            },
            minuteMetrics: {
                type: "VARCHAR(255)"
            },
            hourMetrics: {
                type: "VARCHAR(255)"
            },
            staticWebsite: {
                type: "VARCHAR(1023)"
            },
            deleteRetentionPolicy: {
                type: "VARCHAR(255)"
            }
        }, {
            sequelize: this.sequelize,
            modelName: "Services",
            tableName: "Services",
            timestamps: false
        });
        ContainersModel.init({
            accountName: {
                type: "VARCHAR(32)",
                unique: "accountname_containername"
            },
            // tslint:disable-next-line:max-line-length
            // https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
            containerName: {
                type: "VARCHAR(63)",
                unique: "accountname_containername"
            },
            containerId: {
                type: sequelize_1.INTEGER.UNSIGNED,
                primaryKey: true,
                autoIncrement: true
            },
            lastModified: {
                allowNull: false,
                type: (0, sequelize_1.DATE)(6)
            },
            etag: {
                allowNull: false,
                type: "VARCHAR(127)"
            },
            // TODO: Confirm max length of metadata pairs
            metadata: {
                type: "VARCHAR(4095)"
            },
            containerAcl: {
                type: "VARCHAR(1023)"
            },
            publicAccess: {
                type: "VARCHAR(31)"
            },
            lease: {
                type: "VARCHAR(1023)"
            },
            hasImmutabilityPolicy: {
                type: sequelize_1.BOOLEAN
            },
            hasLegalHold: {
                type: sequelize_1.BOOLEAN
            }
        }, {
            sequelize: this.sequelize,
            modelName: "Containers",
            tableName: "Containers",
            charset: constants_1.DEFAULT_SQL_CHARSET,
            collate: constants_1.DEFAULT_SQL_COLLATE,
            timestamps: false
        });
        BlobsModel.init({
            accountName: {
                type: "VARCHAR(64)",
                allowNull: false
            },
            containerName: {
                type: "VARCHAR(255)",
                allowNull: false
            },
            blobName: {
                type: "VARCHAR(255)",
                allowNull: false
            },
            snapshot: {
                type: "VARCHAR(64)",
                allowNull: false,
                defaultValue: ""
            },
            blobId: {
                type: sequelize_1.INTEGER.UNSIGNED,
                primaryKey: true,
                autoIncrement: true
            },
            lastModified: {
                allowNull: false,
                type: (0, sequelize_1.DATE)(6)
            },
            creationTime: {
                allowNull: false,
                type: (0, sequelize_1.DATE)(6)
            },
            accessTierChangeTime: {
                allowNull: true,
                type: (0, sequelize_1.DATE)(6)
            },
            accessTierInferred: {
                type: sequelize_1.BOOLEAN
            },
            etag: {
                allowNull: false,
                type: "VARCHAR(127)"
            },
            blobType: {
                allowNull: false,
                type: "VARCHAR(31)"
            },
            blobSequenceNumber: {
                type: "VARCHAR(63)"
            },
            accessTier: {
                type: "VARCHAR(31)"
            },
            contentProperties: {
                type: "VARCHAR(1023)"
            },
            lease: {
                type: "VARCHAR(1023)"
            },
            deleting: {
                type: sequelize_1.INTEGER.UNSIGNED,
                defaultValue: 0, // 0 means container is not under deleting(gc)
                allowNull: false
            },
            isCommitted: {
                type: sequelize_1.BOOLEAN,
                allowNull: false
            },
            persistency: {
                type: "VARCHAR(255)"
            },
            committedBlocksInOrder: {
                type: (0, sequelize_1.TEXT)({ length: "medium" })
            },
            metadata: {
                type: "VARCHAR(2047)"
            },
            blobTags: {
                type: "VARCHAR(4096)"
            }
        }, {
            sequelize: this.sequelize,
            modelName: "Blobs",
            tableName: "Blobs",
            timestamps: false,
            charset: constants_1.DEFAULT_SQL_CHARSET,
            collate: constants_1.DEFAULT_SQL_COLLATE,
            indexes: [
                {
                    // name: 'title_index',
                    // using: 'BTREE',
                    unique: true,
                    fields: [
                        "accountName",
                        "containerName",
                        "blobName",
                        "snapshot",
                        "deleting"
                    ]
                }
            ]
        });
        BlocksModel.init({
            accountName: {
                type: "VARCHAR(64)",
                allowNull: false
            },
            containerName: {
                type: "VARCHAR(255)",
                allowNull: false
            },
            blobName: {
                type: "VARCHAR(255)",
                allowNull: false
            },
            // TODO: Check max block name length
            blockName: {
                type: "VARCHAR(64)",
                allowNull: false
            },
            deleting: {
                type: sequelize_1.INTEGER.UNSIGNED,
                defaultValue: 0, // 0 means container is not under deleting(gc)
                allowNull: false
            },
            size: {
                type: sequelize_1.INTEGER.UNSIGNED,
                allowNull: false
            },
            persistency: {
                type: "VARCHAR(255)"
            }
        }, {
            sequelize: this.sequelize,
            modelName: "Blocks",
            tableName: "Blocks",
            timestamps: false,
            indexes: [
                {
                    unique: true,
                    fields: ["accountName", "containerName", "blobName", "blockName"]
                }
            ]
        });
        // TODO: sync() is only for development purpose, use migration for production
        await this.sequelize.sync();
        this.initialized = true;
    }
    isInitialized() {
        return this.initialized;
    }
    async close() {
        await this.sequelize.close();
        this.closed = true;
    }
    isClosed() {
        return this.closed;
    }
    async clean() {
        // TODO: Implement cleanup in database
    }
    async setServiceProperties(context, serviceProperties) {
        return this.sequelize.transaction(async (t) => {
            const findResult = await ServicesModel.findByPk(serviceProperties.accountName, {
                transaction: t
            });
            const updateValues = {
                defaultServiceVersion: serviceProperties.defaultServiceVersion,
                cors: this.serializeModelValue(serviceProperties.cors),
                logging: this.serializeModelValue(serviceProperties.logging),
                minuteMetrics: this.serializeModelValue(serviceProperties.minuteMetrics),
                hourMetrics: this.serializeModelValue(serviceProperties.hourMetrics),
                staticWebsite: this.serializeModelValue(serviceProperties.staticWebsite),
                deleteRetentionPolicy: this.serializeModelValue(serviceProperties.deleteRetentionPolicy)
            };
            if (findResult === null) {
                await ServicesModel.create({
                    accountName: serviceProperties.accountName,
                    ...updateValues
                }, { transaction: t });
            }
            else {
                const updateResult = await ServicesModel.update(updateValues, {
                    transaction: t,
                    where: {
                        accountName: serviceProperties.accountName
                    }
                });
                // Set the exactly equal properties will affect 0 rows.
                const updatedRows = updateResult[0];
                if (updatedRows > 1) {
                    throw Error(`SqlBlobMetadataStore:updateServiceProperties() failed. Update operation affect ${updatedRows} rows.`);
                }
            }
            return serviceProperties;
        });
    }
    async getServiceProperties(context, account) {
        const findResult = await ServicesModel.findByPk(account);
        if (findResult === null) {
            return undefined;
        }
        const logging = this.deserializeModelValue(findResult, "logging");
        const hourMetrics = this.deserializeModelValue(findResult, "hourMetrics");
        const minuteMetrics = this.deserializeModelValue(findResult, "minuteMetrics");
        const cors = this.deserializeModelValue(findResult, "cors");
        const deleteRetentionPolicy = this.deserializeModelValue(findResult, "deleteRetentionPolicy");
        const staticWebsite = this.deserializeModelValue(findResult, "staticWebsite");
        const defaultServiceVersion = this.getModelValue(findResult, "defaultServiceVersion");
        const ret = {
            accountName: account
        };
        if (logging !== undefined) {
            ret.logging = logging;
        }
        if (hourMetrics !== undefined) {
            ret.hourMetrics = hourMetrics;
        }
        if (minuteMetrics !== undefined) {
            ret.minuteMetrics = minuteMetrics;
        }
        if (cors !== undefined) {
            ret.cors = cors;
        }
        if (deleteRetentionPolicy !== undefined) {
            ret.deleteRetentionPolicy = deleteRetentionPolicy;
        }
        if (staticWebsite !== undefined) {
            ret.staticWebsite = staticWebsite;
        }
        if (defaultServiceVersion !== undefined) {
            ret.defaultServiceVersion = defaultServiceVersion;
        }
        return ret;
    }
    async listContainers(context, account, prefix = "", maxResults = constants_2.DEFAULT_LIST_CONTAINERS_MAX_RESULTS, marker) {
        const whereQuery = { accountName: account };
        if (prefix.length > 0) {
            whereQuery.containerName = {
                [sequelize_1.Op.like]: `${prefix}%`
            };
        }
        if (marker !== "") {
            if (whereQuery.containerName === undefined) {
                whereQuery.containerName = {
                    [sequelize_1.Op.gt]: marker
                };
            }
            else {
                whereQuery.containerName[sequelize_1.Op.gt] = marker;
            }
        }
        const findResult = await ContainersModel.findAll({
            limit: maxResults + 1,
            where: whereQuery,
            order: [["containerName", "ASC"]]
        });
        const leaseUpdateMapper = (model) => {
            const containerModel = this.convertDbModelToContainerModel(model);
            return LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context).sync(new ContainerLeaseSyncer_1.default(containerModel));
        };
        if (findResult.length <= maxResults) {
            return [findResult.map(leaseUpdateMapper), undefined];
        }
        else {
            const tail = findResult[findResult.length - 2];
            findResult.pop();
            const nextMarker = this.getModelValue(tail, "containerName", true);
            return [findResult.map(leaseUpdateMapper), nextMarker];
        }
    }
    async createContainer(context, container) {
        try {
            await ContainersModel.create(this.convertContainerModelToDbModel(container));
            return container;
        }
        catch (err) {
            if (err.name === "SequelizeUniqueConstraintError") {
                throw StorageErrorFactory_1.default.getContainerAlreadyExists(context.contextId);
            }
            throw err;
        }
    }
    async getContainerProperties(context, account, container, leaseAccessConditions) {
        const findResult = await this.assertContainerExists(context, account, container, undefined, true);
        const containerModel = this.convertDbModelToContainerModel(findResult);
        return LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
            .validate(new ContainerReadLeaseValidator_1.default(leaseAccessConditions))
            .sync(new ContainerLeaseSyncer_1.default(containerModel));
    }
    async deleteContainer(context, account, container, options = {}) {
        await this.sequelize.transaction(async (t) => {
            /* Transaction starts */
            const findResult = await ContainersModel.findOne({
                attributes: [
                    "accountName",
                    "containerName",
                    "etag",
                    "lastModified",
                    "lease"
                ],
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            LeaseFactory_1.default.createLeaseState(this.convertDbModelToLease(findResult), context).validate(new ContainerDeleteLeaseValidator_1.default(options.leaseAccessConditions));
            await ContainersModel.destroy({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            // TODO: GC blobs under deleting status
            await BlobsModel.update({
                deleting: (0, sequelize_1.literal)("deleting + 1")
            }, {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            // TODO: GC blocks under deleting status
            await BlocksModel.update({
                deleting: (0, sequelize_1.literal)("deleting + 1")
            }, {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            /* Transaction ends */
        });
    }
    async setContainerMetadata(context, account, container, lastModified, etag, metadata, leaseAccessConditions, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            /* Transaction starts */
            const findResult = await ContainersModel.findOne({
                attributes: [
                    "accountName",
                    "containerName",
                    "etag",
                    "lastModified",
                    "lease"
                ],
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            LeaseFactory_1.default.createLeaseState(this.convertDbModelToLease(findResult), context).validate(new ContainerReadLeaseValidator_1.default(leaseAccessConditions));
            await ContainersModel.update({
                lastModified,
                etag,
                metadata: this.serializeModelValue(metadata) || null
            }, {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            /* Transaction ends */
        });
    }
    async getContainerACL(context, account, container, leaseAccessConditions) {
        const findResult = await ContainersModel.findOne({
            where: {
                accountName: account,
                containerName: container
            }
        });
        if (findResult === null || findResult === undefined) {
            throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
        }
        const containerModel = this.convertDbModelToContainerModel(findResult);
        LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
            .validate(new ContainerReadLeaseValidator_1.default(leaseAccessConditions))
            .sync(new ContainerLeaseSyncer_1.default(containerModel));
        return {
            properties: containerModel.properties,
            containerAcl: containerModel.containerAcl
        };
    }
    async setContainerACL(context, account, container, setAclModel) {
        await this.sequelize.transaction(async (t) => {
            const findResult = await ContainersModel.findOne({
                attributes: [
                    "accountName",
                    "containerName",
                    "etag",
                    "lastModified",
                    "lease"
                ],
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, setAclModel.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const lease = this.convertDbModelToLease(findResult);
            LeaseFactory_1.default.createLeaseState(lease, context).validate(new ContainerReadLeaseValidator_1.default(setAclModel.leaseAccessConditions));
            const updateResult = await ContainersModel.update({
                lastModified: setAclModel.lastModified,
                etag: setAclModel.etag,
                containerAcl: this.serializeModelValue(setAclModel.containerAcl) || null,
                publicAccess: this.serializeModelValue(setAclModel.publicAccess)
            }, {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            if (updateResult[0] === 0) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
        });
    }
    async acquireContainerLease(context, account, container, options) {
        return this.sequelize.transaction(async (t) => {
            /* Transaction starts */
            const findResult = await ContainersModel.findOne({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const containerModel = this.convertDbModelToContainerModel(findResult);
            LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
                .acquire(options.duration, options.proposedLeaseId)
                .sync(new ContainerLeaseSyncer_1.default(containerModel));
            await ContainersModel.update(this.convertLeaseToDbModel(new ContainerLeaseAdapter_1.default(containerModel)), {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            return {
                properties: containerModel.properties,
                leaseId: containerModel.leaseId
            };
            /* Transaction ends */
        });
    }
    async releaseContainerLease(context, account, container, leaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            /* Transaction starts */
            const findResult = await ContainersModel.findOne({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const containerModel = this.convertDbModelToContainerModel(findResult);
            LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
                .release(leaseId)
                .sync(new ContainerLeaseSyncer_1.default(containerModel));
            await ContainersModel.update(this.convertLeaseToDbModel(new ContainerLeaseAdapter_1.default(containerModel)), {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            return containerModel.properties;
            /* Transaction ends */
        });
    }
    async renewContainerLease(context, account, container, leaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            /* Transaction starts */
            // TODO: Filter out unnecessary fields in select query
            const findResult = await ContainersModel.findOne({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const containerModel = this.convertDbModelToContainerModel(findResult);
            LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
                .renew(leaseId)
                .sync(new ContainerLeaseSyncer_1.default(containerModel));
            await ContainersModel.update(this.convertLeaseToDbModel(new ContainerLeaseAdapter_1.default(containerModel)), {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            return {
                properties: containerModel.properties,
                leaseId: containerModel.leaseId
            };
            /* Transaction ends */
        });
    }
    async breakContainerLease(context, account, container, breakPeriod, options = {}) {
        return this.sequelize.transaction(async (t) => {
            const findResult = await ContainersModel.findOne({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const containerModel = this.convertDbModelToContainerModel(findResult);
            LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
                .break(breakPeriod)
                .sync(new ContainerLeaseSyncer_1.default(containerModel));
            await ContainersModel.update(this.convertLeaseToDbModel(new ContainerLeaseAdapter_1.default(containerModel)), {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            const leaseTimeSeconds = containerModel.properties.leaseState ===
                Models.LeaseStateType.Breaking && containerModel.leaseBreakTime
                ? Math.round((containerModel.leaseBreakTime.getTime() -
                    context.startTime.getTime()) /
                    1000)
                : 0;
            return {
                properties: containerModel.properties,
                leaseTime: leaseTimeSeconds
            };
        });
    }
    async changeContainerLease(context, account, container, leaseId, proposedLeaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            const findResult = await ContainersModel.findOne({
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, findResult ? this.convertDbModelToContainerModel(findResult) : undefined);
            if (findResult === null || findResult === undefined) {
                throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
            }
            const containerModel = this.convertDbModelToContainerModel(findResult);
            LeaseFactory_1.default.createLeaseState(new ContainerLeaseAdapter_1.default(containerModel), context)
                .change(leaseId, proposedLeaseId)
                .sync(new ContainerLeaseSyncer_1.default(containerModel));
            await ContainersModel.update(this.convertLeaseToDbModel(new ContainerLeaseAdapter_1.default(containerModel)), {
                where: {
                    accountName: account,
                    containerName: container
                },
                transaction: t
            });
            return {
                properties: containerModel.properties,
                leaseId: containerModel.leaseId
            };
        });
    }
    async checkContainerExist(context, account, container) {
        await this.assertContainerExists(context, account, container, undefined);
    }
    async createBlob(context, blob, leaseAccessConditions, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, blob.accountName, blob.containerName, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: blob.accountName,
                    containerName: blob.containerName,
                    blobName: blob.name,
                    snapshot: blob.snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult)
                : undefined);
            // Create if not exists
            if (modifiedAccessConditions &&
                modifiedAccessConditions.ifNoneMatch === "*" &&
                blobFindResult) {
                throw StorageErrorFactory_1.default.getBlobAlreadyExists(context.contextId);
            }
            if (blobFindResult) {
                const blobModel = this.convertDbModelToBlobModel(blobFindResult);
                LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                    .validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions))
                    .sync(new BlobLeaseSyncer_1.default(blob)); // Keep original blob lease;
                if (blobModel.properties !== undefined &&
                    blobModel.properties.accessTier === Models.AccessTier.Archive) {
                    throw StorageErrorFactory_1.default.getBlobArchived(context.contextId);
                }
            }
            await BlobsModel.upsert(this.convertBlobModelToDbModel(blob), {
                transaction: t
            });
        });
    }
    async downloadBlob(context, account, container, blob, snapshot = "", leaseAccessConditions, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, ReadConditionalHeadersValidator_1.validateReadConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult)
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            return LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                .validate(new BlobReadLeaseValidator_1.default(leaseAccessConditions))
                .sync(new BlobLeaseSyncer_1.default(blobModel));
        });
    }
    async listBlobs(context, account, container, delimiter, blob, prefix = "", maxResults = constants_2.DEFAULT_LIST_BLOBS_MAX_RESULTS, marker, includeSnapshots, includeUncommittedBlobs) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const whereQuery = {
                accountName: account,
                containerName: container
            };
            if (blob !== undefined) {
                whereQuery.blobName = blob;
            }
            else {
                if (prefix.length > 0) {
                    whereQuery.blobName = {
                        [sequelize_1.Op.like]: `${prefix}%`
                    };
                }
                if (marker !== undefined) {
                    if (whereQuery.blobName !== undefined) {
                        whereQuery.blobName[sequelize_1.Op.gt] = marker;
                    }
                    else {
                        whereQuery.blobName = {
                            [sequelize_1.Op.gt]: marker
                        };
                    }
                }
            }
            if (!includeSnapshots) {
                whereQuery.snapshot = "";
            }
            if (!includeUncommittedBlobs) {
                whereQuery.isCommitted = true;
            }
            whereQuery.deleting = 0;
            const leaseUpdateMapper = (model) => {
                const blobModel = this.convertDbModelToBlobModel(model);
                return LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).sync(new BlobLeaseSyncer_1.default(blobModel));
            };
            // fill the page by possibly querying multiple times
            const page = new PageWithDelimiter_1.default(maxResults, delimiter, prefix);
            const nameItem = (item) => {
                return this.getModelValue(item, "blobName", true);
            };
            const readPage = async (off) => {
                return await BlobsModel.findAll({
                    where: whereQuery,
                    order: [["blobName", "ASC"]],
                    transaction: t,
                    limit: maxResults,
                    offset: off
                });
            };
            const [blobItems, blobPrefixes, nextMarker] = await page.fill(readPage, nameItem);
            return [blobItems.map(leaseUpdateMapper), blobPrefixes, nextMarker];
        });
    }
    async listAllBlobs(maxResults = constants_2.DEFAULT_LIST_BLOBS_MAX_RESULTS, marker, includeSnapshots, includeUncommittedBlobs) {
        const whereQuery = {};
        if (marker !== undefined) {
            whereQuery.blobName = {
                [sequelize_1.Op.gt]: marker
            };
        }
        if (!includeSnapshots) {
            whereQuery.snapshot = "";
        }
        if (!includeUncommittedBlobs) {
            whereQuery.isCommitted = true;
        }
        whereQuery.deleting = 0;
        const blobFindResult = await BlobsModel.findAll({
            limit: maxResults + 1,
            where: whereQuery,
            order: [["blobName", "ASC"]]
        });
        if (blobFindResult.length <= maxResults) {
            return [
                blobFindResult.map(this.convertDbModelToBlobModel.bind(this)),
                undefined
            ];
        }
        else {
            blobFindResult.pop();
            const tail = blobFindResult[blobFindResult.length - 1];
            const nextMarker = this.getModelValue(tail, "blobName", true);
            return [
                blobFindResult.map(this.convertDbModelToBlobModel.bind(this)),
                nextMarker
            ];
        }
    }
    async stageBlock(context, block, leaseAccessConditions) {
        await this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, block.accountName, block.containerName, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: block.accountName,
                    containerName: block.containerName,
                    blobName: block.blobName,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            if (blobFindResult !== null && blobFindResult !== undefined) {
                const blobModel = this.convertDbModelToBlobModel(blobFindResult);
                if (blobModel.isCommitted === true) {
                    LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions));
                }
                // If the new block ID does not have same length with before uncommited block ID, return failure.
                const existBlock = await BlocksModel.findOne({
                    attributes: ["blockName"],
                    where: {
                        accountName: block.accountName,
                        containerName: block.containerName,
                        blobName: block.blobName,
                        deleting: 0
                    },
                    order: [["id", "ASC"]],
                    transaction: t
                });
                if (existBlock &&
                    Buffer.from(this.getModelValue(existBlock, "blockName", true), "base64").length !== Buffer.from(block.name, "base64").length) {
                    throw StorageErrorFactory_1.default.getInvalidBlobOrBlock(context.contextId);
                }
            }
            else {
                const newBlob = {
                    deleted: false,
                    accountName: block.accountName,
                    containerName: block.containerName,
                    name: block.blobName,
                    properties: {
                        creationTime: context.startTime,
                        lastModified: context.startTime,
                        etag: (0, utils_2.newEtag)(),
                        contentLength: 0,
                        blobType: Models.BlobType.BlockBlob
                    },
                    snapshot: "",
                    isCommitted: false
                };
                await BlobsModel.upsert(this.convertBlobModelToDbModel(newBlob), {
                    transaction: t
                });
            }
            await BlocksModel.upsert({
                accountName: block.accountName,
                containerName: block.containerName,
                blobName: block.blobName,
                blockName: block.name,
                size: block.size,
                persistency: this.serializeModelValue(block.persistency)
            }, { transaction: t });
        });
    }
    getBlockList(context, account, container, blob, snapshot = "", isCommitted, leaseAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot,
                    deleting: 0
                },
                transaction: t
            });
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobReadLeaseValidator_1.default(leaseAccessConditions));
            const res = {
                uncommittedBlocks: [],
                committedBlocks: []
            };
            if (isCommitted !== false) {
                res.committedBlocks = blobModel.committedBlocksInOrder || [];
            }
            if (isCommitted !== true) {
                const blocks = await BlocksModel.findAll({
                    attributes: ["blockName", "size"],
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob,
                        deleting: 0
                    },
                    order: [["id", "ASC"]],
                    transaction: t
                });
                for (const item of blocks) {
                    const block = {
                        name: this.getModelValue(item, "blockName", true),
                        size: this.getModelValue(item, "size", true)
                    };
                    res.uncommittedBlocks.push(block);
                }
            }
            return res;
        });
    }
    async commitBlockList(context, blob, blockList, leaseAccessConditions, modifiedAccessConditions) {
        await this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, blob.accountName, blob.containerName, t);
            const pCommittedBlocksMap = new Map(); // persistencyCommittedBlocksMap
            const pUncommittedBlocksMap = new Map(); // persistencyUncommittedBlocksMap
            const badRequestError = StorageErrorFactory_1.default.getInvalidBlockList(context.contextId);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: blob.accountName,
                    containerName: blob.containerName,
                    blobName: blob.name,
                    snapshot: blob.snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce duplicated convert
                : undefined);
            let creationTime = blob.properties.creationTime || context.startTime;
            if (blobFindResult !== null && blobFindResult !== undefined) {
                const blobModel = this.convertDbModelToBlobModel(blobFindResult);
                // Create if not exists
                if (modifiedAccessConditions &&
                    modifiedAccessConditions.ifNoneMatch === "*" &&
                    blobModel &&
                    blobModel.isCommitted) {
                    throw StorageErrorFactory_1.default.getBlobAlreadyExists(context.contextId);
                }
                creationTime = blobModel.properties.creationTime || creationTime;
                LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions));
                const committedBlocksInOrder = blobModel.committedBlocksInOrder;
                for (const pBlock of committedBlocksInOrder || []) {
                    pCommittedBlocksMap.set(pBlock.name, pBlock);
                }
            }
            const blockFindResult = await BlocksModel.findAll({
                where: {
                    accountName: blob.accountName,
                    containerName: blob.containerName,
                    blobName: blob.name,
                    deleting: 0
                },
                transaction: t
            });
            for (const item of blockFindResult) {
                const block = {
                    name: this.getModelValue(item, "blockName", true),
                    size: this.getModelValue(item, "size", true),
                    persistency: this.deserializeModelValue(item, "persistency")
                };
                pUncommittedBlocksMap.set(block.name, block);
            }
            const selectedBlockList = [];
            for (const block of blockList) {
                switch (block.blockCommitType.toLowerCase()) {
                    case "uncommitted":
                        const pUncommittedBlock = pUncommittedBlocksMap.get(block.blockName);
                        if (pUncommittedBlock === undefined) {
                            throw badRequestError;
                        }
                        else {
                            selectedBlockList.push(pUncommittedBlock);
                        }
                        break;
                    case "committed":
                        const pCommittedBlock = pCommittedBlocksMap.get(block.blockName);
                        if (pCommittedBlock === undefined) {
                            throw badRequestError;
                        }
                        else {
                            selectedBlockList.push(pCommittedBlock);
                        }
                        break;
                    case "latest":
                        const pLatestBlock = pUncommittedBlocksMap.get(block.blockName) ||
                            pCommittedBlocksMap.get(block.blockName);
                        if (pLatestBlock === undefined) {
                            throw badRequestError;
                        }
                        else {
                            selectedBlockList.push(pLatestBlock);
                        }
                        break;
                    default:
                        throw badRequestError;
                }
            }
            const commitBlockBlob = {
                ...blob,
                deleted: false,
                committedBlocksInOrder: selectedBlockList,
                properties: {
                    ...blob.properties,
                    creationTime,
                    lastModified: blob.properties.lastModified || context.startTime,
                    contentLength: selectedBlockList
                        .map((block) => block.size)
                        .reduce((total, val) => {
                        return total + val;
                    }, 0),
                    blobType: Models.BlobType.BlockBlob
                }
            };
            new BlobLeaseSyncer_1.default(commitBlockBlob).sync({
                leaseId: undefined,
                leaseExpireTime: undefined,
                leaseDurationSeconds: undefined,
                leaseBreakTime: undefined,
                leaseDurationType: undefined,
                leaseState: undefined,
                leaseStatus: undefined
            });
            await BlobsModel.upsert(this.convertBlobModelToDbModel(commitBlockBlob), {
                transaction: t
            });
            await BlocksModel.update({
                deleting: (0, sequelize_1.literal)("deleting + 1")
            }, {
                where: {
                    accountName: blob.accountName,
                    containerName: blob.containerName,
                    blobName: blob.name
                },
                transaction: t
            });
        });
    }
    async getBlobProperties(context, account, container, blob, snapshot = "", leaseAccessConditions, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, ReadConditionalHeadersValidator_1.validateReadConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult)
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            if (!blobModel.isCommitted) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            // TODO: Return blobCommittedBlockCount for append blob
            let responds = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                .validate(new BlobReadLeaseValidator_1.default(leaseAccessConditions))
                .sync(new BlobLeaseSyncer_1.default(blobModel));
            return {
                ...responds,
                properties: {
                    ...responds.properties,
                    tagCount: (0, utils_3.getBlobTagsCount)(blobModel.blobTags),
                },
            };
        });
    }
    undeleteBlob() {
        throw new Error("Method not implemented.");
    }
    async createSnapshot(context, account, container, blob, leaseAccessConditions, metadata, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, ReadConditionalHeadersValidator_1.validateReadConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const snapshotBlob = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(snapshotBlob), context).validate(new BlobReadLeaseValidator_1.default(leaseAccessConditions));
            const snapshotTime = (0, utils_1.convertDateTimeStringMsTo7Digital)(context.startTime.toISOString());
            snapshotBlob.snapshot = snapshotTime;
            snapshotBlob.metadata = metadata || snapshotBlob.metadata;
            snapshotBlob.blobTags = snapshotBlob.blobTags;
            new BlobLeaseSyncer_1.default(snapshotBlob).sync({
                leaseId: undefined,
                leaseExpireTime: undefined,
                leaseDurationSeconds: undefined,
                leaseBreakTime: undefined,
                leaseDurationType: undefined,
                leaseState: undefined,
                leaseStatus: undefined
            });
            await BlobsModel.upsert(this.convertBlobModelToDbModel(snapshotBlob), {
                transaction: t
            });
            return {
                properties: snapshotBlob.properties,
                snapshot: snapshotTime
            };
        });
    }
    async deleteBlob(context, account, container, blob, options) {
        await this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: options.snapshot === undefined ? "" : options.snapshot,
                    deleting: 0,
                    isCommitted: true // TODO: Support deleting uncommitted block blob
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const againstBaseBlob = blobModel.snapshot === "";
            if (againstBaseBlob) {
                LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobWriteLeaseValidator_1.default(options.leaseAccessConditions));
            }
            // Check bad requests
            if (!againstBaseBlob && options.deleteSnapshots !== undefined) {
                throw StorageErrorFactory_1.default.getInvalidOperation(context.contextId, "Invalid operation against a blob snapshot.");
            }
            // Scenario: Delete base blob only
            if (againstBaseBlob && options.deleteSnapshots === undefined) {
                const count = await BlobsModel.count({
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob,
                        deleting: 0
                    },
                    transaction: t
                });
                if (count > 1) {
                    throw StorageErrorFactory_1.default.getSnapshotsPresent(context.contextId);
                }
                else {
                    await BlobsModel.update({
                        deleting: (0, sequelize_1.literal)("deleting + 1")
                    }, {
                        where: {
                            accountName: account,
                            containerName: container,
                            blobName: blob
                        },
                        transaction: t
                    });
                    await BlocksModel.update({
                        deleting: (0, sequelize_1.literal)("deleting + 1")
                    }, {
                        where: {
                            accountName: account,
                            containerName: container,
                            blobName: blob
                        },
                        transaction: t
                    });
                }
            }
            // Scenario: Delete one snapshot only
            if (!againstBaseBlob) {
                await BlobsModel.update({
                    deleting: (0, sequelize_1.literal)("deleting + 1")
                }, {
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob,
                        snapshot: blobModel.snapshot
                    },
                    transaction: t
                });
            }
            // Scenario: Delete base blob and snapshots
            if (againstBaseBlob &&
                options.deleteSnapshots === Models.DeleteSnapshotsOptionType.Include) {
                await BlobsModel.update({
                    deleting: (0, sequelize_1.literal)("deleting + 1")
                }, {
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob
                    },
                    transaction: t
                });
                await BlocksModel.update({
                    deleting: (0, sequelize_1.literal)("deleting + 1")
                }, {
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob
                    },
                    transaction: t
                });
            }
            // Scenario: Delete all snapshots only
            if (againstBaseBlob &&
                options.deleteSnapshots === Models.DeleteSnapshotsOptionType.Only) {
                await BlobsModel.update({
                    deleting: (0, sequelize_1.literal)("deleting + 1")
                }, {
                    where: {
                        accountName: account,
                        containerName: container,
                        blobName: blob,
                        snapshot: { [sequelize_1.Op.gt]: "" }
                    },
                    transaction: t
                });
            }
        });
    }
    async setBlobHTTPHeaders(context, account, container, blob, leaseAccessConditions, blobHTTPHeaders, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                .validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions))
                .sync(new BlobWriteLeaseSyncer_1.default(blobModel));
            if (blobHTTPHeaders !== undefined) {
                blobModel.properties.cacheControl = blobHTTPHeaders.blobCacheControl;
                blobModel.properties.contentType = blobHTTPHeaders.blobContentType;
                blobModel.properties.contentMD5 = blobHTTPHeaders.blobContentMD5;
                blobModel.properties.contentEncoding =
                    blobHTTPHeaders.blobContentEncoding;
                blobModel.properties.contentLanguage =
                    blobHTTPHeaders.blobContentLanguage;
                blobModel.properties.contentDisposition =
                    blobHTTPHeaders.blobContentDisposition;
            }
            blobModel.properties.etag = (0, utils_2.newEtag)();
            blobModel.properties.lastModified = context.startTime
                ? context.startTime
                : new Date();
            await BlobsModel.update(this.convertBlobModelToDbModel(blobModel), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return blobModel.properties;
        });
    }
    setBlobMetadata(context, account, container, blob, leaseAccessConditions, metadata, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                .validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions))
                .sync(new BlobWriteLeaseSyncer_1.default(blobModel));
            const lastModified = context.startTime || new Date();
            const etag = (0, utils_2.newEtag)();
            await BlobsModel.update({
                metadata: this.serializeModelValue(metadata) || null,
                lastModified,
                etag,
                ...this.convertLeaseToDbModel(new BlobLeaseAdapter_1.default(blobModel))
            }, {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            const ret = {
                lastModified,
                etag,
                leaseStatus: blobModel.properties.leaseStatus,
                leaseDuration: blobModel.properties.leaseDuration,
                leaseState: blobModel.properties.leaseState
            };
            return ret;
        });
    }
    async acquireBlobLease(context, account, container, blob, duration, proposedLeaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const lease = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).acquire(duration, proposedLeaseId).lease;
            await BlobsModel.update(this.convertLeaseToDbModel(lease), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return { properties: blobModel.properties, leaseId: lease.leaseId };
        });
    }
    async releaseBlobLease(context, account, container, blob, leaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const lease = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).release(leaseId).lease;
            await BlobsModel.update(this.convertLeaseToDbModel(lease), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return blobModel.properties;
        });
    }
    async renewBlobLease(context, account, container, blob, leaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const lease = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).renew(leaseId).lease;
            await BlobsModel.update(this.convertLeaseToDbModel(lease), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return { properties: blobModel.properties, leaseId: lease.leaseId };
        });
    }
    async changeBlobLease(context, account, container, blob, leaseId, proposedLeaseId, options = {}) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const lease = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).change(leaseId, proposedLeaseId).lease;
            await BlobsModel.update(this.convertLeaseToDbModel(lease), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return { properties: blobModel.properties, leaseId: lease.leaseId };
        });
    }
    async breakBlobLease(context, account, container, blob, breakPeriod, options = {}) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, blobFindResult
                ? this.convertDbModelToBlobModel(blobFindResult) // TODO: Reduce double convert
                : undefined);
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            const lease = LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).break(breakPeriod).lease;
            const leaseTimeSeconds = lease.leaseState === Models.LeaseStateType.Breaking &&
                lease.leaseBreakTime
                ? Math.round((lease.leaseBreakTime.getTime() - context.startTime.getTime()) /
                    1000)
                : 0;
            await BlobsModel.update(this.convertLeaseToDbModel(lease), {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return { properties: blobModel.properties, leaseTime: leaseTimeSeconds };
        });
    }
    async checkBlobExist(context, account, container, blob, snapshot) {
        await this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const res = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: snapshot ? snapshot : "",
                    deleting: 0
                },
                transaction: t
            });
            if (res === null || res === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
        });
    }
    async getBlobType(account, container, blob, snapshot) {
        const res = await BlobsModel.findOne({
            where: {
                accountName: account,
                containerName: container,
                blobName: blob,
                snapshot: snapshot ? snapshot : "",
                deleting: 0
            }
        });
        if (res === null || res === undefined) {
            return undefined;
        }
        const blobType = this.getModelValue(res, "blobType", true);
        const isCommitted = this.getModelValue(res, "isCommitted", true);
        return { blobType, isCommitted };
    }
    startCopyFromURL(context, source, destination, copySource, metadata, tier, options = {}) {
        return this.sequelize.transaction(async (t) => {
            const sourceBlob = await this.getBlobWithLeaseUpdated(source.account, source.container, source.blob, source.snapshot, context, true, true, t);
            options.sourceModifiedAccessConditions =
                options.sourceModifiedAccessConditions || {};
            (0, ReadConditionalHeadersValidator_1.validateReadConditions)(context, {
                ifModifiedSince: options.sourceModifiedAccessConditions.sourceIfModifiedSince,
                ifUnmodifiedSince: options.sourceModifiedAccessConditions.sourceIfUnmodifiedSince,
                ifMatch: options.sourceModifiedAccessConditions.sourceIfMatch,
                ifNoneMatch: options.sourceModifiedAccessConditions.sourceIfNoneMatch
            }, sourceBlob);
            const destBlob = await this.getBlobWithLeaseUpdated(destination.account, destination.container, destination.blob, undefined, context, false, undefined, t);
            (0, WriteConditionalHeadersValidator_1.validateWriteConditions)(context, options.modifiedAccessConditions, destBlob);
            if (destBlob) {
                new BlobWriteLeaseValidator_1.default(options.leaseAccessConditions).validate(new BlobLeaseAdapter_1.default(destBlob), context);
            }
            // If source is uncommitted or deleted
            if (sourceBlob === undefined ||
                sourceBlob.deleted ||
                !sourceBlob.isCommitted) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            if (sourceBlob.properties.accessTier === Models.AccessTier.Archive
                && (tier === undefined || source.account !== destination.account)) {
                throw StorageErrorFactory_1.default.getBlobArchived(context.contextId);
            }
            await this.assertContainerExists(context, destination.account, destination.container, t);
            // Deep clone a copied blob
            const copiedBlob = {
                name: destination.blob,
                deleted: false,
                snapshot: "",
                properties: {
                    ...sourceBlob.properties,
                    creationTime: context.startTime,
                    lastModified: context.startTime,
                    etag: (0, utils_2.newEtag)(),
                    leaseStatus: destBlob !== undefined
                        ? destBlob.properties.leaseStatus
                        : Models.LeaseStatusType.Unlocked,
                    leaseState: destBlob !== undefined
                        ? destBlob.properties.leaseState
                        : Models.LeaseStateType.Available,
                    leaseDuration: destBlob !== undefined
                        ? destBlob.properties.leaseDuration
                        : undefined,
                    copyId: (0, v4_1.default)(),
                    copyStatus: Models.CopyStatusType.Success,
                    copySource,
                    copyProgress: sourceBlob.properties.contentLength
                        ? `${sourceBlob.properties.contentLength}/${sourceBlob.properties.contentLength}`
                        : undefined,
                    copyCompletionTime: context.startTime,
                    copyStatusDescription: undefined,
                    incrementalCopy: false,
                    destinationSnapshot: undefined,
                    deletedTime: undefined,
                    remainingRetentionDays: undefined,
                    archiveStatus: undefined,
                    accessTierChangeTime: undefined
                },
                metadata: metadata === undefined || Object.keys(metadata).length === 0
                    ? { ...sourceBlob.metadata }
                    : metadata,
                accountName: destination.account,
                containerName: destination.container,
                pageRangesInOrder: sourceBlob.pageRangesInOrder,
                isCommitted: sourceBlob.isCommitted,
                leaseDurationSeconds: destBlob !== undefined ? destBlob.leaseDurationSeconds : undefined,
                leaseId: destBlob !== undefined ? destBlob.leaseId : undefined,
                leaseExpireTime: destBlob !== undefined ? destBlob.leaseExpireTime : undefined,
                leaseBreakTime: destBlob !== undefined ? destBlob.leaseBreakTime : undefined,
                committedBlocksInOrder: sourceBlob.committedBlocksInOrder,
                persistency: sourceBlob.persistency,
                blobTags: options.blobTagsString === undefined ? undefined : (0, utils_3.getTagsFromString)(options.blobTagsString, context.contextId)
            };
            if (copiedBlob.properties.blobType === Models.BlobType.BlockBlob &&
                tier !== undefined) {
                copiedBlob.properties.accessTier = this.parseTier(tier);
                if (copiedBlob.properties.accessTier === undefined) {
                    throw StorageErrorFactory_1.default.getInvalidHeaderValue(context.contextId, {
                        HeaderName: "x-ms-access-tier",
                        HeaderValue: `${tier}`
                    });
                }
            }
            if (copiedBlob.properties.blobType === Models.BlobType.PageBlob &&
                tier !== undefined) {
                throw StorageErrorFactory_1.default.getInvalidHeaderValue(context.contextId, {
                    HeaderName: "x-ms-access-tier",
                    HeaderValue: `${tier}`
                });
            }
            await BlobsModel.upsert(this.convertBlobModelToDbModel(copiedBlob), {
                transaction: t
            });
            return copiedBlob.properties;
        });
    }
    copyFromURL(context, source, destination, copySource, metadata) {
        throw new Error("Method not implemented.");
    }
    setTier(context, account, container, blob, tier, leaseAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            let responseCode = 200;
            // check the lease action aligned with current lease state.
            // the API has not lease ID input, but run it on a lease blocked blob will fail with LeaseIdMissing,
            // this is aligned with server behavior
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions));
            // Check Blob is not snapshot
            const snapshot = blobModel.snapshot;
            if (snapshot !== "") {
                throw StorageErrorFactory_1.default.getBlobSnapshotsPresent(context.contextId);
            }
            // Check BlobTier matches blob type
            let accessTier = blobModel.properties.accessTier;
            const blobType = blobModel.properties.blobType;
            if ((tier === Models.AccessTier.Archive ||
                tier === Models.AccessTier.Cool ||
                tier === Models.AccessTier.Hot ||
                tier === Models.AccessTier.Cold) &&
                blobType === Models.BlobType.BlockBlob) {
                // Block blob
                // tslint:disable-next-line:max-line-length
                // TODO: check blob is not block blob with snapshot, throw StorageErrorFactory.getBlobSnapshotsPresent_hassnapshot()
                // Archive -> Coo/Hot will return 202
                if (accessTier === Models.AccessTier.Archive &&
                    (tier === Models.AccessTier.Cool || tier === Models.AccessTier.Hot || tier === Models.AccessTier.Cold)) {
                    responseCode = 202;
                }
                accessTier = tier;
            }
            else {
                throw StorageErrorFactory_1.default.getAccessTierNotSupportedForBlobType(context.contextId);
            }
            await BlobsModel.update({
                accessTier,
                accessTierInferred: false,
                accessTierChangeTime: context.startTime
            }, {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: "",
                    deleting: 0
                },
                transaction: t
            });
            return responseCode;
        });
    }
    uploadPages(context, blob, start, end, persistency, leaseAccessConditions, modifiedAccessConditions) {
        throw new Error("Method not implemented.");
    }
    clearRange(context, blob, start, end, leaseAccessConditions, modifiedAccessConditions) {
        throw new Error("Method not implemented.");
    }
    getPageRanges(context, account, container, blob, snapshot, leaseAccessConditions, modifiedAccessConditions) {
        throw new Error("Method not implemented.");
    }
    resizePageBlob(context, account, container, blob, blobContentLength, leaseAccessConditions, modifiedAccessConditions) {
        throw new Error("Method not implemented.");
    }
    updateSequenceNumber(context, account, container, blob, sequenceNumberAction, blobSequenceNumber) {
        throw new Error("Method not implemented.");
    }
    appendBlock(context, block, leaseAccessConditions, modifiedAccessConditions, appendPositionAccessConditions) {
        throw new Error("Method not implemented.");
    }
    async listUncommittedBlockPersistencyChunks(marker = "-1", maxResults = 2000) {
        return BlocksModel.findAll({
            attributes: ["id", "persistency"],
            where: {
                id: {
                    [sequelize_1.Op.gt]: parseInt(marker, 10)
                },
                deleting: 0
            },
            limit: maxResults + 1,
            order: [["id", "ASC"]]
        }).then((res) => {
            if (res.length < maxResults) {
                return [
                    res.map((obj) => {
                        return this.deserializeModelValue(obj, "persistency", true);
                    }),
                    undefined
                ];
            }
            else {
                res.pop();
                const nextMarker = this.getModelValue(res[res.length - 1], "id", true);
                return [
                    res.map((obj) => this.deserializeModelValue(obj, "persistency", true)),
                    nextMarker
                ];
            }
        });
    }
    iteratorExtents() {
        return new BlobReferredExtentsAsyncIterator_1.default(this);
    }
    async assertContainerExists(context, account, container, transaction, fullResult = false) {
        const findResult = await ContainersModel.findOne({
            attributes: fullResult ? undefined : ["accountName"],
            where: {
                accountName: account,
                containerName: container
            },
            transaction
        });
        if (findResult === undefined || findResult === null) {
            throw StorageErrorFactory_1.default.getContainerNotFound(context.contextId);
        }
        return findResult;
    }
    getModelValue(model, key, isRequired) {
        let value = model.get(key);
        if (value === null) {
            value = undefined;
        }
        if (value === undefined && isRequired === true) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`SqlBlobMetadataStore:getModelValue() error. ${key} is required but value from database model is undefined.`);
        }
        return value;
    }
    deserializeModelValue(model, key, isRequired = false) {
        const rawValue = this.getModelValue(model, key);
        if (typeof rawValue === "string") {
            // TODO: Decouple deserializer
            return JSON.parse(rawValue);
        }
        if (isRequired) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            `SqlBlobMetadataStore:deserializeModelValue() error. ${key} is required but value from database model is undefined.`);
        }
        return undefined;
    }
    serializeModelValue(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return JSON.stringify(value);
    }
    /**
     * This method will restore object to Uint8Array.
     *
     * @private
     * @param {*} obj
     * @returns {(Uint8Array | undefined)}
     * @memberof LokiBlobMetadataStore
     */
    restoreUint8Array(obj) {
        if (typeof obj !== "object") {
            return undefined;
        }
        if (obj instanceof Uint8Array) {
            return obj;
        }
        if (obj.type === "Buffer") {
            obj = obj.data;
        }
        const length = Object.keys(obj).length;
        const arr = Buffer.allocUnsafe(length);
        for (let i = 0; i < length; i++) {
            if (!obj.hasOwnProperty(i)) {
                throw new TypeError(`Cannot restore sql DB persisted object to Uint8Array. Key ${i} is missing.`);
            }
            arr[i] = obj[i];
        }
        return arr;
    }
    convertDbModelToContainerModel(dbModel) {
        const accountName = this.getModelValue(dbModel, "accountName", true);
        const name = this.getModelValue(dbModel, "containerName", true);
        const containerAcl = this.deserializeModelValue(dbModel, "containerAcl");
        const metadata = this.deserializeModelValue(dbModel, "metadata");
        const lastModified = this.getModelValue(dbModel, "lastModified", true);
        const etag = this.getModelValue(dbModel, "etag", true);
        const publicAccess = this.deserializeModelValue(dbModel, "publicAccess");
        const lease = this.convertDbModelToLease(dbModel);
        const leaseBreakTime = lease.leaseBreakTime;
        const leaseExpireTime = lease.leaseExpireTime;
        const leaseId = lease.leaseId;
        const leaseDurationSeconds = lease.leaseDurationSeconds;
        const leaseStatus = lease.leaseStatus;
        const leaseState = lease.leaseState;
        const leaseDuration = lease.leaseDurationType;
        const hasImmutabilityPolicy = this.getModelValue(dbModel, "hasImmutabilityPolicy");
        const hasLegalHold = this.getModelValue(dbModel, "hasLegalHold");
        const ret = {
            accountName,
            name,
            properties: {
                lastModified,
                etag,
                leaseStatus,
                leaseDuration,
                leaseState
            },
            leaseId,
            leaseBreakTime,
            leaseExpireTime,
            leaseDurationSeconds
        };
        if (metadata !== undefined) {
            ret.metadata = metadata;
        }
        if (containerAcl !== undefined) {
            ret.containerAcl = containerAcl;
        }
        if (publicAccess !== undefined) {
            ret.properties.publicAccess = publicAccess;
        }
        if (hasImmutabilityPolicy !== undefined) {
            ret.properties.hasImmutabilityPolicy = hasImmutabilityPolicy;
        }
        if (hasLegalHold !== undefined) {
            ret.properties.hasLegalHold = hasLegalHold;
        }
        return ret;
    }
    convertContainerModelToDbModel(container) {
        const lease = new ContainerLeaseAdapter_1.default(container).toString();
        return {
            accountName: container.accountName,
            containerName: container.name,
            lastModified: container.properties.lastModified,
            etag: container.properties.etag,
            metadata: this.serializeModelValue(container.metadata),
            containerAcl: this.serializeModelValue(container.containerAcl),
            publicAccess: this.serializeModelValue(container.properties.publicAccess),
            lease,
            hasImmutabilityPolicy: container.properties.hasImmutabilityPolicy,
            hasLegalHold: container.properties.hasLegalHold
        };
    }
    convertDbModelToBlobModel(dbModel) {
        const contentProperties = this.convertDbModelToBlobContentProperties(dbModel);
        const lease = this.convertDbModelToLease(dbModel);
        return {
            accountName: this.getModelValue(dbModel, "accountName", true),
            containerName: this.getModelValue(dbModel, "containerName", true),
            name: this.getModelValue(dbModel, "blobName", true),
            snapshot: this.getModelValue(dbModel, "snapshot", true),
            isCommitted: this.getModelValue(dbModel, "isCommitted", true),
            properties: {
                lastModified: this.getModelValue(dbModel, "lastModified", true),
                etag: this.getModelValue(dbModel, "etag", true),
                leaseDuration: lease.leaseDurationType,
                creationTime: this.getModelValue(dbModel, "creationTime"),
                leaseState: lease.leaseState,
                leaseStatus: lease.leaseStatus,
                accessTier: this.getModelValue(dbModel, "accessTier"),
                accessTierInferred: this.getModelValue(dbModel, "accessTierInferred"),
                accessTierChangeTime: this.getModelValue(dbModel, "accessTierChangeTime"),
                blobSequenceNumber: this.getModelValue(dbModel, "blobSequenceNumber"),
                blobType: this.getModelValue(dbModel, "blobType"),
                contentMD5: contentProperties
                    ? this.restoreUint8Array(contentProperties.contentMD5)
                    : undefined,
                contentDisposition: contentProperties
                    ? contentProperties.contentDisposition
                    : undefined,
                contentEncoding: contentProperties
                    ? contentProperties.contentEncoding
                    : undefined,
                contentLanguage: contentProperties
                    ? contentProperties.contentLanguage
                    : undefined,
                contentLength: contentProperties
                    ? contentProperties.contentLength
                    : undefined,
                contentType: contentProperties
                    ? contentProperties.contentType
                    : undefined,
                cacheControl: contentProperties
                    ? contentProperties.cacheControl
                    : undefined
            },
            leaseDurationSeconds: lease.leaseDurationSeconds,
            leaseBreakTime: lease.leaseBreakTime,
            leaseExpireTime: lease.leaseExpireTime,
            leaseId: lease.leaseId,
            persistency: this.deserializeModelValue(dbModel, "persistency"),
            committedBlocksInOrder: this.deserializeModelValue(dbModel, "committedBlocksInOrder"),
            metadata: this.deserializeModelValue(dbModel, "metadata"),
            blobTags: this.deserializeModelValue(dbModel, "blobTags")
        };
    }
    convertBlobModelToDbModel(blob) {
        const contentProperties = this.convertBlobContentPropertiesToDbModel(blob.properties);
        const lease = this.convertLeaseToDbModel(new BlobLeaseAdapter_1.default(blob));
        return {
            accountName: blob.accountName,
            containerName: blob.containerName,
            blobName: blob.name,
            snapshot: blob.snapshot,
            blobType: blob.properties.blobType,
            blobSequenceNumber: blob.properties.blobSequenceNumber || null,
            isCommitted: blob.isCommitted,
            lastModified: blob.properties.lastModified,
            creationTime: blob.properties.creationTime || null,
            etag: blob.properties.etag,
            accessTier: blob.properties.accessTier || null,
            accessTierChangeTime: blob.properties.accessTierChangeTime || null,
            accessTierInferred: blob.properties.accessTierInferred || null,
            leaseBreakExpireTime: blob.leaseBreakTime || null,
            leaseExpireTime: blob.leaseExpireTime || null,
            leaseId: blob.leaseId || null,
            leasedurationNumber: blob.leaseDurationSeconds || null,
            leaseDuration: blob.properties.leaseDuration || null,
            leaseStatus: blob.properties.leaseStatus || null,
            leaseState: blob.properties.leaseState || null,
            ...lease,
            persistency: this.serializeModelValue(blob.persistency) || null,
            committedBlocksInOrder: this.serializeModelValue(blob.committedBlocksInOrder) || null,
            metadata: this.serializeModelValue(blob.metadata) || null,
            blobTags: this.serializeModelValue(blob.blobTags) || null,
            ...contentProperties
        };
    }
    convertDbModelToBlobContentProperties(dbModel) {
        return this.deserializeModelValue(dbModel, "contentProperties");
    }
    convertBlobContentPropertiesToDbModel(contentProperties) {
        return {
            contentProperties: this.serializeModelValue({
                contentLength: contentProperties.contentLength,
                contentType: contentProperties.contentType,
                contentEncoding: contentProperties.contentEncoding,
                contentLanguage: contentProperties.contentLanguage,
                contentMD5: contentProperties.contentMD5,
                contentDisposition: contentProperties.contentDisposition,
                cacheControl: contentProperties.cacheControl
            }) || null
        };
    }
    convertDbModelToLease(dbModel) {
        const lease = this.deserializeModelValue(dbModel, "lease") || {};
        if (lease.leaseBreakTime && typeof lease.leaseBreakTime === "string") {
            lease.leaseBreakTime = new Date(lease.leaseBreakTime);
        }
        if (lease.leaseExpireTime && typeof lease.leaseExpireTime === "string") {
            lease.leaseExpireTime = new Date(lease.leaseExpireTime);
        }
        return lease;
    }
    convertLeaseToDbModel(lease) {
        let leaseString = "";
        if (lease instanceof ContainerLeaseAdapter_1.default ||
            lease instanceof BlobLeaseAdapter_1.default) {
            leaseString = lease.toString();
        }
        else {
            leaseString = JSON.stringify(lease);
        }
        return { lease: leaseString };
    }
    async getBlobWithLeaseUpdated(account, container, blob, snapshot = "", context, forceExist, forceCommitted, transaction) {
        await this.checkContainerExist(context, account, container);
        const blobFindResult = await BlobsModel.findOne({
            where: {
                accountName: account,
                containerName: container,
                blobName: blob,
                snapshot
            },
            transaction
        });
        if (blobFindResult === null || blobFindResult === undefined) {
            if (forceExist === false) {
                return undefined;
            }
            else {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
        }
        // Force exist if parameter forceExist is undefined or true
        const doc = this.convertDbModelToBlobModel(blobFindResult);
        if (forceExist === undefined || forceExist === true) {
            if (forceCommitted) {
                if (!doc || !doc.isCommitted) {
                    throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
                }
            }
            else {
                if (!doc) {
                    throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
                }
            }
        }
        else {
            if (forceCommitted) {
                if (!doc || !doc.isCommitted) {
                    return undefined;
                }
            }
            else {
                if (!doc) {
                    return undefined;
                }
            }
        }
        if (doc.properties) {
            doc.properties.contentMD5 = this.restoreUint8Array(doc.properties.contentMD5);
        }
        // Snapshot doesn't have lease
        if (snapshot !== undefined && snapshot !== "") {
            new BlobLeaseSyncer_1.default(doc).sync({
                leaseId: undefined,
                leaseExpireTime: undefined,
                leaseDurationSeconds: undefined,
                leaseBreakTime: undefined,
                leaseDurationType: undefined,
                leaseState: Models.LeaseStateType.Available, // TODO: Lease state & status should be undefined for snapshots
                leaseStatus: Models.LeaseStatusType.Unlocked // TODO: Lease state & status should be undefined for snapshots
            });
        }
        else {
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(doc), context).sync(new BlobLeaseSyncer_1.default(doc));
        }
        return doc;
    }
    setBlobTag(context, account, container, blob, snapshot, leaseAccessConditions, tags, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: snapshot === undefined ? "" : snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context)
                .validate(new BlobWriteLeaseValidator_1.default(leaseAccessConditions))
                .sync(new BlobWriteLeaseSyncer_1.default(blobModel));
            await BlobsModel.update({
                blobTags: this.serializeModelValue(tags) || null,
                ...this.convertLeaseToDbModel(new BlobLeaseAdapter_1.default(blobModel))
            }, {
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot: snapshot === undefined ? "" : snapshot,
                    deleting: 0
                },
                transaction: t
            });
        });
    }
    async getBlobTag(context, account, container, blob, snapshot = "", leaseAccessConditions, modifiedAccessConditions) {
        return this.sequelize.transaction(async (t) => {
            await this.assertContainerExists(context, account, container, t);
            const blobFindResult = await BlobsModel.findOne({
                where: {
                    accountName: account,
                    containerName: container,
                    blobName: blob,
                    snapshot,
                    deleting: 0,
                    isCommitted: true
                },
                transaction: t
            });
            if (blobFindResult === null || blobFindResult === undefined) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            const blobModel = this.convertDbModelToBlobModel(blobFindResult);
            if (!blobModel.isCommitted) {
                throw StorageErrorFactory_1.default.getBlobNotFound(context.contextId);
            }
            LeaseFactory_1.default.createLeaseState(new BlobLeaseAdapter_1.default(blobModel), context).validate(new BlobReadLeaseValidator_1.default(leaseAccessConditions));
            return blobModel.blobTags;
        });
    }
    /**
     * Get the tier setting from request headers.
     *
     * @private
     * @param {string} tier
     * @returns {(Models.AccessTier | undefined)}
     * @memberof BlobHandler
     */
    parseTier(tier) {
        tier = tier.toLowerCase();
        if (tier === Models.AccessTier.Hot.toLowerCase()) {
            return Models.AccessTier.Hot;
        }
        if (tier === Models.AccessTier.Cool.toLowerCase()) {
            return Models.AccessTier.Cool;
        }
        if (tier === Models.AccessTier.Archive.toLowerCase()) {
            return Models.AccessTier.Archive;
        }
        if (tier === Models.AccessTier.Cold.toLowerCase()) {
            return Models.AccessTier.Cold;
        }
        return undefined;
    }
}
exports.default = SqlBlobMetadataStore;
//# sourceMappingURL=SqlBlobMetadataStore.js.map