"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const StorageError_1 = tslib_1.__importDefault(require("./StorageError"));
const DefaultID = "DefaultBlobRequestID";
/**
 * A factory class maintains all Azure Storage Blob service errors.
 *
 * @export
 * @class StorageErrorFactory
 */
class StorageErrorFactory {
    static getContainerNotFound(contextID = DefaultID) {
        return new StorageError_1.default(404, "ContainerNotFound", "The specified container does not exist.", contextID);
    }
    static getRequestEntityTooLarge(contextID = DefaultID) {
        return new StorageError_1.default(413, "RequestEntityTooLarge", "The uploaded entity blob is too large.", contextID);
    }
    static getBlockCountExceedsLimit(contextID = DefaultID) {
        return new StorageError_1.default(409, "BlockCountExceedsLimit", "The committed block count cannot exceed the maximum limit of 50,000 blocks.", contextID);
    }
    static getContainerAlreadyExists(contextID = DefaultID) {
        return new StorageError_1.default(409, "ContainerAlreadyExists", "The specified container already exists.", contextID);
    }
    static getBlobAlreadyExists(contextID = DefaultID) {
        return new StorageError_1.default(409, "BlobAlreadyExists", "The specified blob already exists.", contextID);
    }
    static getBlobNotFound(contextID = DefaultID) {
        return new StorageError_1.default(404, "BlobNotFound", "The specified blob does not exist.", contextID);
    }
    static ResourceNotFound(contextID = DefaultID) {
        return new StorageError_1.default(404, "ResourceNotFound", "The specified resource does not exist.", contextID);
    }
    static getInvalidQueryParameterValue(contextID = DefaultID, parameterName, parameterValue, reason) {
        const additionalMessages = {};
        if (parameterName) {
            additionalMessages.QueryParameterName = parameterName;
        }
        if (parameterValue) {
            additionalMessages.QueryParameterValue = parameterValue;
        }
        if (reason) {
            additionalMessages.Reason = reason;
        }
        return new StorageError_1.default(400, "InvalidQueryParameterValue", `Value for one of the query parameters specified in the request URI is invalid.`, contextID, additionalMessages);
    }
    static getOutOfRangeInput(contextID = DefaultID, parameterName, parameterValue, reason) {
        const additionalMessages = {};
        if (parameterName) {
            additionalMessages.QueryParameterName = parameterName;
        }
        if (parameterValue) {
            additionalMessages.QueryParameterValue = parameterValue;
        }
        if (reason) {
            additionalMessages.Reason = reason;
        }
        return new StorageError_1.default(400, "OutOfRangeInput", `One of the request inputs is out of range.`, contextID, additionalMessages);
    }
    static getInvalidOperation(contextID = DefaultID, message = "") {
        return new StorageError_1.default(400, "InvalidOperation", message, contextID);
    }
    static getInvalidBlockList(contextID = DefaultID) {
        return new StorageError_1.default(400, "InvalidBlockList", "The specified block list is invalid.", contextID);
    }
    static getInvalidAuthenticationInfo(contextID = DefaultID) {
        return new StorageError_1.default(400, "InvalidAuthenticationInfo", "Authentication information is not given in the correct format. Check the value of Authorization header.", contextID);
    }
    static getMd5Mismatch(contextID = DefaultID, userSpecifiedMd5, serverCalculatedMd5) {
        return new StorageError_1.default(400, "Md5Mismatch", "The MD5 value specified in the request did not match with the MD5 value calculated by the server.", contextID, {
            UserSpecifiedMd5: userSpecifiedMd5,
            ServerCalculatedMd5: serverCalculatedMd5
        });
    }
    static getInvalidPageRange(contextID) {
        return new StorageError_1.default(416, "Requested Range Not Satisfiable", "The page range specified is invalid.", contextID);
    }
    static getInvalidLeaseDuration(contextID = DefaultID) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", contextID);
    }
    static getInvalidLeaseBreakPeriod(contextID = DefaultID) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", contextID);
    }
    static getInvalidId(contextID) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", contextID);
    }
    static getInvalidBlobOrBlock(contextID = DefaultID) {
        return new StorageError_1.default(400, "InvalidBlobOrBlock", "The specified blob or block content is invalid.", contextID);
    }
    static getLeaseAlreadyPresent(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseAlreadyPresent", "There is already a lease present.", contextID);
    }
    static getLeaseIsBreakingAndCannotBeAcquired(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseIsBreakingAndCannotBeAcquired", "There is already a breaking lease, and can't  be acquired.", contextID);
    }
    static getLeaseNotPresentWithLeaseOperation(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseNotPresentWithLeaseOperation", "There is currently no lease on the container or blob.", contextID);
    }
    static getLeaseIdMismatchWithLeaseOperation(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseIdMismatchWithLeaseOperation", "The lease ID specified did not match the lease ID for the container or blob.", contextID);
    }
    static getLeaseIsBrokenAndCannotBeRenewed(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseIsBrokenAndCannotBeRenewed", "The lease ID matched, but the lease has been broken explicitly and cannot be renewed.", contextID);
    }
    static getLeaseIsBreakingAndCannotBeChanged(contextID = DefaultID) {
        return new StorageError_1.default(409, "LeaseIsBreakingAndCannotBeChanged", "The lease ID matched, but the lease is currently in breaking state and cannot be changed.", contextID);
    }
    static getContainerLeaseIdMissing(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseIdMissing", "There is currently a lease on the container and no lease ID was specified in the request.", contextID);
    }
    static getContainerLeaseIdMismatchWithContainerOperation(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseIdMismatchWithContainerOperation", "The lease ID specified did not match the lease ID for the container.", contextID);
    }
    static getContainerLeaseLost(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseNotPresentWithContainerOperation", "A lease ID was specified, but the lease for the container has expired.", contextID);
    }
    static getBlobLeaseIdMismatchWithLeaseOperation(contextID) {
        return new StorageError_1.default(409, "LeaseIdMismatchWithLeaseOperation", "The lease ID specified did not match the lease ID for the blob.", contextID);
    }
    static getBlobLeaseNotPresentWithLeaseOperation(contextID) {
        return new StorageError_1.default(409, "LeaseNotPresentWithLeaseOperation", "There is currently no lease on the blob.", contextID);
    }
    // The error code/message need check with server
    static getBlobSnapshotsPresent(contextID = DefaultID) {
        return new StorageError_1.default(400, "SnapshotsPresent", "This operation is not permitted because the blob is snapshot.", contextID);
    }
    static getBlobLeaseIdMissing(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseIdMissing", "There is currently a lease on the blob and no lease ID was specified in the request.", contextID);
    }
    static getBlobLeaseIdMismatchWithBlobOperation(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseIdMismatchWithBlobOperation", "The lease ID specified did not match the lease ID for the blob.", contextID);
    }
    static getBlobLeaseLost(contextID = DefaultID) {
        return new StorageError_1.default(412, "LeaseNotPresentWithBlobOperation", "A lease ID was specified, but the lease for the blob has expired.", contextID);
    }
    static getAuthorizationFailure(contextID) {
        return new StorageError_1.default(403, "AuthorizationFailure", 
        // tslint:disable-next-line:max-line-length
        "Server failed to authenticate the request. Make sure the value of the Authorization header is formed correctly including the signature.", contextID);
    }
    static getAuthenticationFailed(contextID = DefaultID, authenticationErrorDetail) {
        return new StorageError_1.default(403, "AuthenticationFailed", "Server failed to authenticate the request. Make sure the value of the Authorization header is formed correctly including the signature.", contextID, {
            AuthenticationErrorDetail: authenticationErrorDetail
        });
    }
    static getBlobInvalidBlobType(contextID = DefaultID) {
        return new StorageError_1.default(409, "InvalidBlobType", "The blob type is invalid for this operation.", contextID);
    }
    static getAccessTierNotSupportedForBlobType(contextID) {
        return new StorageError_1.default(400, "AccessTierNotSupportedForBlobType", "The access tier is not supported for this blob type.", contextID);
    }
    static getMultipleConditionHeadersNotSupported(contextID) {
        return new StorageError_1.default(400, "MultipleConditionHeadersNotSupported", "Multiple condition headers are not supported.", contextID);
    }
    static getBlobSnapshotsPresent_hassnapshot(contextID) {
        return new StorageError_1.default(409, "SnapshotsPresent", "This operation is not permitted because the blob has snapshots.", contextID);
    }
    static getBlobCannotChangeToLowerTier(contextID) {
        return new StorageError_1.default(409, "CannotChangeToLowerTier", "A higher blob tier has already been explicitly set.", contextID);
    }
    static getBlobBlobTierInadequateForContentLength(contextID) {
        return new StorageError_1.default(409, "BlobTierInadequateForContentLength", "Specified blob tier size limit cannot be less than content length.", contextID);
    }
    static getAuthorizationSourceIPMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationSourceIPMismatch", "This request is not authorized to perform this operation using this source IP {SourceIP}.", contextID);
    }
    static getAuthorizationProtocolMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationProtocolMismatch", "This request is not authorized to perform this operation using this protocol.", contextID);
    }
    static getAuthorizationPermissionMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationPermissionMismatch", "This request is not authorized to perform this operation using this permission.", contextID);
    }
    static getAuthorizationServiceMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationServiceMismatch", "This request is not authorized to perform this operation using this service.", contextID);
    }
    static getAuthorizationResourceTypeMismatch(contextID) {
        return new StorageError_1.default(403, "AuthorizationResourceTypeMismatch", "This request is not authorized to perform this operation using this resource type.", contextID);
    }
    static getFeatureVersionMismatch(contextID) {
        return new StorageError_1.default(409, "FeatureVersionMismatch", "Stored access policy contains a permission that is not supported by this version.", contextID);
    }
    static getCopyIdMismatch(contextID) {
        return new StorageError_1.default(409, "CopyIdMismatch", "The specified copy ID did not match the copy ID for the pending copy operation.", contextID);
    }
    static getNoPendingCopyOperation(contextID) {
        return new StorageError_1.default(409, "NoPendingCopyOperation", "There is currently no pending copy operation.", contextID);
    }
    static getSnapshotsPresent(contextID) {
        return new StorageError_1.default(409, "SnapshotsPresent", "This operation is not permitted while the blob has snapshots.", contextID);
    }
    static getConditionNotMet(contextID) {
        return new StorageError_1.default(412, "ConditionNotMet", "The condition specified using HTTP conditional header(s) is not met.", contextID);
    }
    static getMaxBlobSizeConditionNotMet(contextID = DefaultID) {
        return new StorageError_1.default(412, "MaxBlobSizeConditionNotMet", "The max blob size condition specified was not met.", contextID);
    }
    static getAppendPositionConditionNotMet(contextID = DefaultID) {
        return new StorageError_1.default(412, "AppendPositionConditionNotMet", "The append position condition specified was not met.", contextID);
    }
    static getSequenceNumberConditionNotMet(contextID) {
        return new StorageError_1.default(412, "SequenceNumberConditionNotMet", "The condition specified using HTTP conditional header(s) is not met.", contextID);
    }
    static getNotModified(contextID) {
        return new StorageError_1.default(304, "ConditionNotMet", "The condition specified using HTTP conditional header(s) is not met.", contextID);
    }
    static getUnsatisfiableCondition(contextID) {
        return new StorageError_1.default(400, "UnsatisfiableCondition", "The request includes an unsatisfiable condition for this operation.", contextID);
    }
    static getInvalidHeaderValue(contextID = "", additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(400, "InvalidHeaderValue", "The value for one of the HTTP headers is not in the correct format.", contextID, additionalMessages);
    }
    static getInvalidAPIVersion(contextID = "", apiVersion) {
        return new StorageError_1.default(400, "InvalidHeaderValue", `The API version ${apiVersion} is not supported by Azurite. Please upgrade Azurite to latest version and retry. If you are using Azurite in Visual Studio, please check you have installed latest Visual Studio patch. Azurite command line parameter \"--skipApiVersionCheck\" or Visual Studio Code configuration \"Skip Api Version Check\" can skip this error. `, contextID);
    }
    static getBlobArchived(contextID = "", additionalMessages) {
        if (additionalMessages === undefined) {
            additionalMessages = {};
        }
        return new StorageError_1.default(409, "BlobArchived", "This operation is not permitted on an archived blob.", contextID, additionalMessages);
    }
    static getInvalidCorsHeaderValue(contextID = "", additionalMessages) {
        return new StorageError_1.default(400, "InvalidHeaderValue", "A required CORS header is not present.", contextID, additionalMessages);
    }
    static corsPreflightFailure(contextID = "", additionalMessages) {
        return new StorageError_1.default(403, "CorsPreflightFailure", "CORS not enabled or no matching rule found for this request.", contextID, additionalMessages);
    }
    static getCannotVerifyCopySource(contextID, statusCode, message, additionalMessages) {
        return new StorageError_1.default(statusCode, "CannotVerifyCopySource", message, contextID, additionalMessages);
    }
    static getInvalidResourceName(contextID = "") {
        return new StorageError_1.default(400, "InvalidResourceName", `The specifed resource name contains invalid characters.`, contextID);
    }
    static getOutOfRangeName(contextID = "") {
        return new StorageError_1.default(400, "OutOfRangeInput", `The specified resource name length is not within the permissible limits.`, contextID);
    }
    static getUnexpectedSyncCopyStatus(contextID, copyStatus) {
        return new StorageError_1.default(409, "UnexpectedSyncCopyStatus", 'Expected copyStatus to be "success" but got different status.', contextID, { ReceivedCopyStatus: copyStatus });
    }
    static getInvalidMetadata(contextID) {
        return new StorageError_1.default(400, "InvalidMetadata", "The metadata specified is invalid. It has characters that are not permitted.", contextID);
    }
    static getEmptyTagName(contextID) {
        return new StorageError_1.default(400, "EmptyTagName", "The name of one of the tag key-value pairs is empty.", contextID);
    }
    static getDuplicateTagNames(contextID) {
        return new StorageError_1.default(400, "DuplicateTagNames", "The tags specified contain duplicate names.", contextID);
    }
    static getTagsTooLarge(contextID) {
        return new StorageError_1.default(400, "TagsTooLarge", "The tags specified exceed the maximum permissible limit.", contextID);
    }
    static getInvalidTag(contextID) {
        return new StorageError_1.default(400, "DuplicateTagNames", "The tags specified are invalid. It contains characters that are not permitted.", contextID);
    }
    static getInvaidXmlDocument(contextID = "") {
        return new StorageError_1.default(400, "InvaidXmlDocument", `XML specified is not syntactically valid.`, contextID);
    }
}
exports.default = StorageErrorFactory;
//# sourceMappingURL=StorageErrorFactory.js.map