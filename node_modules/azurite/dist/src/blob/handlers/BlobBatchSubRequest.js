"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobBatchSubRequest = void 0;
const ms_rest_js_1 = require("@azure/ms-rest-js");
const stream_1 = require("stream");
class BlobBatchSubRequest {
    constructor(content_id, url, method, protocolWithVersion, headers) {
        this.content_id = content_id;
        this.url = url;
        this.method = method;
        this.protocolWithVersion = protocolWithVersion;
        this.headers = headers;
        this.urlbuilder = ms_rest_js_1.URLBuilder.parse(this.url);
    }
    getMethod() {
        return this.method;
    }
    getUrl() {
        return this.url;
    }
    getEndpoint() {
        const urlbuilder = ms_rest_js_1.URLBuilder.parse(this.url);
        return `${urlbuilder.getScheme()}://${urlbuilder.getHost()}`;
    }
    getPath() {
        const path = this.urlbuilder.getPath();
        if (path)
            return path;
        return "";
    }
    getBodyStream() {
        return stream_1.Readable.from([]);
    }
    getBody() {
        return undefined;
    }
    setBody(body) {
        return this;
    }
    getHeader(field) {
        if (!field) {
            throw new TypeError('field argument is required to getHeader');
        }
        if (typeof field !== 'string') {
            throw new TypeError('name must be a string to getHeader');
        }
        const lc = field.toLowerCase();
        return this.headers[lc];
    }
    getHeaders() {
        return this.headers;
    }
    getRawHeaders() {
        return [];
    }
    getQuery(key) {
        const queryValue = this.urlbuilder.getQueryParameterValue(key);
        return queryValue === undefined ? undefined : queryValue.toString();
    }
    getProtocol() {
        return this.urlbuilder.getScheme();
    }
    setHeader(key, value) {
        this.headers[key.toLowerCase()] = value;
    }
}
exports.BlobBatchSubRequest = BlobBatchSubRequest;
//# sourceMappingURL=BlobBatchSubRequest.js.map