"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateReadConditions = void 0;
const tslib_1 = require("tslib");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const ConditionalHeadersAdapter_1 = tslib_1.__importDefault(require("./ConditionalHeadersAdapter"));
const ConditionResourceAdapter_1 = tslib_1.__importDefault(require("./ConditionResourceAdapter"));
function validateReadConditions(context, conditionalHeaders, model) {
    new ReadConditionalHeadersValidator().validate(context, new ConditionalHeadersAdapter_1.default(context, conditionalHeaders), new ConditionResourceAdapter_1.default(model));
}
exports.validateReadConditions = validateReadConditions;
// tslint:disable: max-line-length
class ReadConditionalHeadersValidator {
    /**
     * Validate Conditional Headers for Blob Service Read Operations in Version 2013-08-15 or Later.
     * @link https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations#specifying-conditional-headers-for-blob-service-read-operations-in-version-2013-08-15-or-later
     *
     * @param context
     * @param conditionalHeaders
     * @param resource
     */
    validate(context, conditionalHeaders, resource) {
        // If-Match && If-Unmodified-Since && (If-None-Match || If-Modified-Since)
        // Read against a non exist resource
        if (!resource.exist) {
            // If-Match
            if (conditionalHeaders.ifMatch && conditionalHeaders.ifMatch.length > 0) {
                throw StorageErrorFactory_1.default.getConditionNotMet(context.contextId);
            }
            // If If-Unmodified-Since
            // Skip for unexist resource
            // If-None-Match
            if (conditionalHeaders.ifNoneMatch &&
                conditionalHeaders.ifNoneMatch.length > 0 &&
                conditionalHeaders.ifNoneMatch[0] === "*") {
                throw StorageErrorFactory_1.default.getUnsatisfiableCondition(context.contextId);
            }
            // If-Modified-Since
            // Skip for unexist resource
        }
        else {
            // Read against an existing resource
            // If-Match && If-Unmodified-Since && (If-None-Match || If-Modified-Since)
            // If-Match
            const ifMatchPass = conditionalHeaders.ifMatch
                ? conditionalHeaders.ifMatch.includes(resource.etag) ||
                    conditionalHeaders.ifMatch[0] === "*"
                : undefined;
            // If-Unmodified-Since
            const ifUnModifiedSincePass = conditionalHeaders.ifUnmodifiedSince
                ? resource.lastModified <= conditionalHeaders.ifUnmodifiedSince
                : undefined;
            // If-None-Match
            if (conditionalHeaders.ifNoneMatch &&
                conditionalHeaders.ifNoneMatch.length > 0 &&
                conditionalHeaders.ifNoneMatch[0] === "*") {
                throw StorageErrorFactory_1.default.getUnsatisfiableCondition(context.contextId);
            }
            const ifNoneMatchPass = conditionalHeaders.ifNoneMatch
                ? !conditionalHeaders.ifNoneMatch.includes(resource.etag)
                : undefined;
            // If-Modified-Since
            const isModifiedSincePass = conditionalHeaders.ifModifiedSince
                ? conditionalHeaders.ifModifiedSince < resource.lastModified
                : undefined;
            if (ifMatchPass === false) {
                throw StorageErrorFactory_1.default.getConditionNotMet(context.contextId);
            }
            if (ifUnModifiedSincePass === false) {
                throw StorageErrorFactory_1.default.getConditionNotMet(context.contextId);
            }
            if (ifNoneMatchPass === false && isModifiedSincePass !== true) {
                throw StorageErrorFactory_1.default.getNotModified(context.contextId);
            }
            if (isModifiedSincePass === false && ifNoneMatchPass !== true) {
                throw StorageErrorFactory_1.default.getNotModified(context.contextId);
            }
        }
    }
}
exports.default = ReadConditionalHeadersValidator;
//# sourceMappingURL=ReadConditionalHeadersValidator.js.map