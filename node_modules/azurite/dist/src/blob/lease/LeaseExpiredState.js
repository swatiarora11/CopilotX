"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid = require("uuid");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
const LeaseAvailableState_1 = tslib_1.__importDefault(require("./LeaseAvailableState"));
const LeaseBrokenState_1 = tslib_1.__importDefault(require("./LeaseBrokenState"));
const LeaseLeasedState_1 = tslib_1.__importDefault(require("./LeaseLeasedState"));
const LeaseStateBase_1 = tslib_1.__importDefault(require("./LeaseStateBase"));
class LeaseExpiredState extends LeaseStateBase_1.default {
    constructor(lease, context) {
        if (context.startTime === undefined) {
            throw RangeError(`LeaseExpiredState:constructor() error, context.startTime is undefined.`);
        }
        if (lease.leaseState === models_1.LeaseStateType.Expired) {
            /*
             * LeaseState: Expired
             * LeaseStatus: Unlocked
             * LeaseDurationType: undefined
             * LeaseExpireTime: undefined
             * LeaseDurationSeconds: number
             * LeaseBreakTime: undefined
             * LeaseId: uuid
             */
            if (lease.leaseStatus !== models_1.LeaseStatusType.Unlocked) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Unlocked}.`);
            }
            if (lease.leaseId === undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
            }
            if (lease.leaseExpireTime !== undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is undefined.`);
            }
            if (lease.leaseDurationSeconds === undefined ||
                lease.leaseDurationSeconds === -1) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is undefined or -1 (infinite).`);
            }
            if (lease.leaseDurationType !== undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not undefined.`);
            }
            if (lease.leaseBreakTime !== undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is not undefined.`);
            }
            // Deep copy
            super({ ...lease }, context);
        }
        else if (lease.leaseState === models_1.LeaseStateType.Leased) {
            /*
             * LeaseState: Leased
             * LeaseStatus: Locked
             * LeaseDurationType: Fixed
             * LeaseExpireTime: now >= timestamp
             * LeaseDurationSeconds: number (not -1)
             * LeaseBreakTime: undefined
             * LeaseId: uuid
             */
            if (lease.leaseStatus !== models_1.LeaseStatusType.Locked) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Locked}.`);
            }
            if (lease.leaseId === undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
            }
            if (lease.leaseExpireTime === undefined ||
                context.startTime < lease.leaseExpireTime) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is undefined, or larger than current time ${context.startTime}.`);
            }
            if (lease.leaseDurationSeconds === undefined ||
                lease.leaseDurationSeconds === -1) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is undefined or -1 (infinite).`);
            }
            if (lease.leaseDurationType !== models_1.LeaseDurationType.Fixed) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not ${models_1.LeaseDurationType.Fixed}.`);
            }
            if (lease.leaseBreakTime !== undefined) {
                throw RangeError(`LeaseExpiredState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is not undefined.`);
            }
            super({
                leaseId: lease.leaseId,
                leaseState: models_1.LeaseStateType.Expired,
                leaseStatus: models_1.LeaseStatusType.Unlocked,
                leaseDurationType: undefined,
                leaseDurationSeconds: lease.leaseDurationSeconds,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, context);
        }
        else {
            throw RangeError(`LeaseExpiredState:constructor() error, incoming lease state ${lease.leaseState} is neither ${models_1.LeaseStateType.Expired} or ${models_1.LeaseStateType.Leased}.`);
        }
    }
    acquire(duration, proposedLeaseId = "") {
        if ((duration < 15 || duration > 60) && duration !== -1) {
            throw StorageErrorFactory_1.default.getInvalidLeaseDuration(this.context.contextId);
        }
        // TODO: Validate proposedLeaseId follows GUID format
        if (duration === -1) {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Infinite,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        else {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Fixed,
                leaseDurationSeconds: duration,
                leaseExpireTime: new Date(this.context.startTime.getTime() + duration * 1000),
                leaseBreakTime: undefined
            }, this.context);
        }
    }
    break(breakPeriod) {
        return new LeaseBrokenState_1.default({
            leaseId: this.lease.leaseId,
            leaseState: models_1.LeaseStateType.Broken,
            leaseStatus: models_1.LeaseStatusType.Unlocked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: undefined
        }, this.context);
    }
    renew() {
        return new LeaseLeasedState_1.default({
            leaseId: this.lease.leaseId,
            leaseState: models_1.LeaseStateType.Leased,
            leaseStatus: models_1.LeaseStatusType.Locked,
            leaseDurationType: models_1.LeaseDurationType.Fixed,
            leaseDurationSeconds: this.lease.leaseDurationSeconds,
            leaseExpireTime: new Date(this.context.startTime.getTime() +
                this.lease.leaseDurationSeconds * 1000),
            leaseBreakTime: undefined
        }, this.context);
    }
    change() {
        throw StorageErrorFactory_1.default.getLeaseNotPresentWithLeaseOperation(this.context.contextId);
    }
    release(leaseId) {
        if (this.lease.leaseId !== leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        return new LeaseAvailableState_1.default({
            leaseId: undefined,
            leaseState: models_1.LeaseStateType.Available,
            leaseStatus: models_1.LeaseStatusType.Unlocked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: undefined
        }, this.context);
    }
}
exports.default = LeaseExpiredState;
//# sourceMappingURL=LeaseExpiredState.js.map