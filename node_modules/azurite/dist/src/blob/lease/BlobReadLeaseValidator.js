"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
class BlobReadLeaseValidator {
    constructor(leaseAccessConditions) {
        this.leaseAccessConditions = leaseAccessConditions;
    }
    validate(lease, context) {
        // Check only when input Leased Id is not empty
        if (this.leaseAccessConditions !== undefined &&
            this.leaseAccessConditions.leaseId !== undefined &&
            this.leaseAccessConditions.leaseId !== "") {
            // Return error when lease is unlocked
            if (lease.leaseStatus === models_1.LeaseStatusType.Unlocked) {
                throw StorageErrorFactory_1.default.getBlobLeaseLost(context.contextId);
            }
            else if (lease.leaseId !== undefined &&
                this.leaseAccessConditions.leaseId.toLowerCase() !==
                    lease.leaseId.toLowerCase()) {
                // Return error when lease is locked but lease ID not match
                throw StorageErrorFactory_1.default.getBlobLeaseIdMismatchWithBlobOperation(context.contextId);
            }
        }
    }
}
exports.default = BlobReadLeaseValidator;
//# sourceMappingURL=BlobReadLeaseValidator.js.map