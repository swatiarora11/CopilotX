"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid = require("uuid");
const utils_1 = require("../../common/utils/utils");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
const LeaseAvailableState_1 = tslib_1.__importDefault(require("./LeaseAvailableState"));
const LeaseBreakingState_1 = tslib_1.__importDefault(require("./LeaseBreakingState"));
const LeaseBrokenState_1 = tslib_1.__importDefault(require("./LeaseBrokenState"));
const LeaseStateBase_1 = tslib_1.__importDefault(require("./LeaseStateBase"));
class LeaseLeasedState extends LeaseStateBase_1.default {
    constructor(lease, context) {
        /*
         * LeaseState: Leased
         * LeaseStatus: Locked
         * LeaseDurationType: Fixed || Infinite
         * LeaseExpireTime: now < timestamp || undefined
         * LeaseDurationSeconds: number || -1
         * LeaseBreakTime: undefined
         * LeaseId: uuid
         */
        if (context.startTime === undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, context.startTime is undefined.`);
        }
        if (lease.leaseState !== models_1.LeaseStateType.Leased) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming lease state ${lease.leaseState} is not ${models_1.LeaseStateType.Leased}.`);
        }
        if (lease.leaseStatus !== models_1.LeaseStatusType.Locked) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Locked}.`);
        }
        if (lease.leaseId === undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
        }
        if (lease.leaseExpireTime !== undefined &&
            context.startTime >= lease.leaseExpireTime) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is not undefined, and smaller than current time ${context.startTime}.`);
        }
        // leaseDurationSeconds could be number or undefined
        // if (
        //   lease.leaseDurationSeconds !== undefined &&
        //   lease.leaseDurationSeconds !== -1
        // ) {
        //   throw RangeError(
        // tslint:disable-next-line:max-line-length
        //     `LeaseLeasedState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is not undefined, and not equal to -1.`
        //   );
        // }
        if (lease.leaseDurationType === undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is undefined.`);
        }
        if (lease.leaseBreakTime !== undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is not undefined.`);
        }
        // Deep copy
        super({ ...lease }, context);
    }
    acquire(duration, proposedLeaseId = "") {
        if (proposedLeaseId !== this.lease.leaseId) {
            // TODO: Check error message
            throw StorageErrorFactory_1.default.getLeaseAlreadyPresent(this.context.contextId);
        }
        if ((duration < 15 || duration > 60) && duration !== -1) {
            throw StorageErrorFactory_1.default.getInvalidLeaseDuration(this.context.contextId);
        }
        // TODO: Validate proposedLeaseId follows GUID format
        if (duration === -1) {
            return new LeaseLeasedState({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Infinite,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        else {
            return new LeaseLeasedState({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Fixed,
                leaseDurationSeconds: duration,
                leaseExpireTime: new Date(this.context.startTime.getTime() + duration * 1000),
                leaseBreakTime: undefined
            }, this.context);
        }
    }
    break(breakPeriod) {
        if (this.lease.leaseDurationType === models_1.LeaseDurationType.Infinite) {
            if (breakPeriod === 0 || breakPeriod === undefined) {
                return new LeaseBrokenState_1.default({
                    leaseId: this.lease.leaseId,
                    leaseState: models_1.LeaseStateType.Broken,
                    leaseStatus: models_1.LeaseStatusType.Unlocked,
                    leaseDurationType: undefined,
                    leaseDurationSeconds: undefined,
                    leaseExpireTime: undefined,
                    leaseBreakTime: undefined
                }, this.context);
            }
            else {
                return new LeaseBreakingState_1.default({
                    leaseId: this.lease.leaseId,
                    leaseState: models_1.LeaseStateType.Breaking,
                    leaseStatus: models_1.LeaseStatusType.Locked,
                    leaseDurationType: undefined,
                    leaseDurationSeconds: undefined,
                    leaseExpireTime: undefined,
                    leaseBreakTime: new Date(this.context.startTime.getTime() + breakPeriod * 1000)
                }, this.context);
            }
        }
        // Following only cares about this.lease.leaseDurationType === LeaseDurationType.Fixed
        if (breakPeriod === 0) {
            return new LeaseBrokenState_1.default({
                leaseId: this.lease.leaseId,
                leaseState: models_1.LeaseStateType.Broken,
                leaseStatus: models_1.LeaseStatusType.Unlocked,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        if (breakPeriod === undefined) {
            return new LeaseBreakingState_1.default({
                leaseId: this.lease.leaseId,
                leaseState: models_1.LeaseStateType.Breaking,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: this.lease.leaseExpireTime
            }, this.context);
        }
        if (breakPeriod < 0 || breakPeriod > 60) {
            throw StorageErrorFactory_1.default.getInvalidLeaseBreakPeriod(this.context.contextId);
        }
        // Following only cares about breakPeriod between (0, 60]
        const breakTime = new Date(this.context.startTime.getTime() + breakPeriod * 1000);
        return new LeaseBreakingState_1.default({
            leaseId: this.lease.leaseId,
            leaseState: models_1.LeaseStateType.Breaking,
            leaseStatus: models_1.LeaseStatusType.Locked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: (0, utils_1.minDate)(this.lease.leaseExpireTime, breakTime)
        }, this.context);
    }
    renew(leaseId) {
        if (this.lease.leaseId !== leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        if (this.lease.leaseDurationType === models_1.LeaseDurationType.Infinite) {
            return this;
        }
        // Renew a fixed lease
        return new LeaseLeasedState({
            leaseId: this.lease.leaseId,
            leaseState: models_1.LeaseStateType.Leased,
            leaseStatus: models_1.LeaseStatusType.Locked,
            leaseDurationType: models_1.LeaseDurationType.Fixed,
            leaseDurationSeconds: this.lease.leaseDurationSeconds,
            leaseExpireTime: new Date(this.context.startTime.getTime() +
                this.lease.leaseDurationSeconds * 1000),
            leaseBreakTime: undefined
        }, this.context);
    }
    change(leaseId, proposedLeaseId) {
        if (this.lease.leaseId !== leaseId &&
            this.lease.leaseId !== proposedLeaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        return new LeaseLeasedState({
            leaseId: proposedLeaseId,
            leaseState: models_1.LeaseStateType.Leased,
            leaseStatus: models_1.LeaseStatusType.Locked,
            leaseDurationType: this.lease.leaseDurationType,
            leaseDurationSeconds: this.lease.leaseDurationSeconds,
            leaseExpireTime: this.lease.leaseExpireTime,
            leaseBreakTime: undefined
        }, this.context);
    }
    release(leaseId) {
        if (this.lease.leaseId !== leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        return new LeaseAvailableState_1.default({
            leaseId: undefined,
            leaseState: models_1.LeaseStateType.Available,
            leaseStatus: models_1.LeaseStatusType.Unlocked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: undefined
        }, this.context);
    }
}
exports.default = LeaseLeasedState;
//# sourceMappingURL=LeaseLeasedState.js.map