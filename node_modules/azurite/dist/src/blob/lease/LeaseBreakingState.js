"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("../../common/utils/utils");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
const LeaseAvailableState_1 = tslib_1.__importDefault(require("./LeaseAvailableState"));
const LeaseBrokenState_1 = tslib_1.__importDefault(require("./LeaseBrokenState"));
const LeaseStateBase_1 = tslib_1.__importDefault(require("./LeaseStateBase"));
class LeaseBreakingState extends LeaseStateBase_1.default {
    constructor(lease, context) {
        /*
         * LeaseState: Breaking
         * LeaseStatus: Locked
         * LeaseDurationType: undefined
         * LeaseExpireTime: undefined
         * LeaseDurationSeconds: undefined
         * LeaseBreakTime: Now < timestamp
         * LeaseId: uuid
         */
        if (context.startTime === undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, context.startTime is undefined.`);
        }
        if (lease.leaseState !== models_1.LeaseStateType.Breaking) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming lease state ${lease.leaseState} is not ${models_1.LeaseStateType.Breaking}.`);
        }
        if (lease.leaseStatus !== models_1.LeaseStatusType.Locked) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Locked}.`);
        }
        if (lease.leaseId === undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
        }
        if (lease.leaseExpireTime !== undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is not undefined.`);
        }
        if (lease.leaseDurationSeconds !== undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is not undefined.`);
        }
        if (lease.leaseDurationType !== undefined) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not undefined.`);
        }
        if (lease.leaseBreakTime === undefined ||
            context.startTime >= lease.leaseBreakTime // Current time should be less than break time
        ) {
            throw RangeError(`LeaseLeasedState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is undefined, or less than current time ${context.startTime}.`);
        }
        // Deep copy
        super({ ...lease }, context);
    }
    acquire(duration, proposedLeaseId = "") {
        if (proposedLeaseId === this.lease.leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIsBreakingAndCannotBeAcquired(this.context.contextId);
        }
        else {
            throw StorageErrorFactory_1.default.getLeaseAlreadyPresent(this.context.contextId);
        }
    }
    break(breakPeriod) {
        if (breakPeriod === undefined) {
            return this;
        }
        if (breakPeriod === 0) {
            return new LeaseBrokenState_1.default({
                leaseId: this.lease.leaseId,
                leaseState: models_1.LeaseStateType.Broken,
                leaseStatus: models_1.LeaseStatusType.Unlocked,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        if (breakPeriod > 0 && breakPeriod <= 60) {
            const breakTime = new Date(this.context.startTime.getTime() + breakPeriod * 1000);
            return new LeaseBreakingState({
                leaseId: this.lease.leaseId,
                leaseState: models_1.LeaseStateType.Breaking,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: (0, utils_1.minDate)(this.lease.leaseBreakTime, breakTime)
            }, this.context);
        }
        throw StorageErrorFactory_1.default.getInvalidLeaseBreakPeriod(this.context.contextId);
    }
    renew(proposedLeaseId) {
        if (proposedLeaseId === this.lease.leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIsBrokenAndCannotBeRenewed(this.context.contextId);
        }
        else {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
    }
    change(proposedLeaseId) {
        if (proposedLeaseId === this.lease.leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIsBreakingAndCannotBeChanged(this.context.contextId);
        }
        else {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
    }
    release(leaseId) {
        if (this.lease.leaseId !== leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        return new LeaseAvailableState_1.default({
            leaseId: undefined,
            leaseState: models_1.LeaseStateType.Available,
            leaseStatus: models_1.LeaseStatusType.Unlocked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: undefined
        }, this.context);
    }
}
exports.default = LeaseBreakingState;
//# sourceMappingURL=LeaseBreakingState.js.map