"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid = require("uuid");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
const LeaseLeasedState_1 = tslib_1.__importDefault(require("./LeaseLeasedState"));
const LeaseStateBase_1 = tslib_1.__importDefault(require("./LeaseStateBase"));
/**
 * Available lease state.
 *
 * @export
 * @class LeaseAvailableState
 */
class LeaseAvailableState extends LeaseStateBase_1.default {
    constructor(lease, context) {
        /*
         * LeaseState: Available
         * LeaseStatus: Unlocked
         * LeaseDurationType: undefined
         * LeaseExpireTime: undefined
         * LeaseDurationSeconds: undefined
         * LeaseBreakTime: undefined
         * LeaseId: undefined
         */
        if (context.startTime === undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, context.startTime is undefined.`);
        }
        if (lease.leaseState === undefined) {
            super({
                leaseId: undefined,
                leaseState: undefined,
                leaseStatus: undefined,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, context);
            return;
        }
        if (lease.leaseState !== models_1.LeaseStateType.Available) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming lease state ${lease.leaseState} is not ${models_1.LeaseStateType.Available}.`);
        }
        if (lease.leaseStatus !== models_1.LeaseStatusType.Unlocked) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Unlocked}.`);
        }
        if (lease.leaseId !== undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming leaseId ${lease.leaseId} is not undefined.`);
        }
        if (lease.leaseExpireTime !== undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is not undefined.`);
        }
        if (lease.leaseDurationSeconds !== undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is not undefined.`);
        }
        if (lease.leaseDurationType !== undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not undefined.`);
        }
        if (lease.leaseBreakTime !== undefined) {
            throw RangeError(`LeaseAvailableState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is not undefined.`);
        }
        // Deep copy
        super({ ...lease }, context);
    }
    acquire(duration, proposedLeaseId = "") {
        if ((duration < 15 || duration > 60) && duration !== -1) {
            throw StorageErrorFactory_1.default.getInvalidLeaseDuration(this.context.contextId);
        }
        // TODO: Validate proposedLeaseId follows GUID format
        if (duration === -1) {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Infinite,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        else {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Fixed,
                leaseDurationSeconds: duration,
                leaseExpireTime: new Date(this.context.startTime.getTime() + duration * 1000),
                leaseBreakTime: undefined
            }, this.context);
        }
    }
    break() {
        throw StorageErrorFactory_1.default.getLeaseNotPresentWithLeaseOperation(this.context.contextId);
    }
    renew(leaseId) {
        throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
    }
    change() {
        throw StorageErrorFactory_1.default.getLeaseNotPresentWithLeaseOperation(this.context.contextId);
    }
    release(leaseId) {
        throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
    }
}
exports.default = LeaseAvailableState;
//# sourceMappingURL=LeaseAvailableState.js.map