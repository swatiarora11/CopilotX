"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const uuid = require("uuid");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const models_1 = require("../generated/artifacts/models");
const LeaseAvailableState_1 = tslib_1.__importDefault(require("./LeaseAvailableState"));
const LeaseLeasedState_1 = tslib_1.__importDefault(require("./LeaseLeasedState"));
const LeaseStateBase_1 = tslib_1.__importDefault(require("./LeaseStateBase"));
class LeaseBrokenState extends LeaseStateBase_1.default {
    constructor(lease, context) {
        if (context.startTime === undefined) {
            throw RangeError(`LeaseBrokenState:constructor() error, context.startTime is undefined.`);
        }
        if (lease.leaseState === models_1.LeaseStateType.Broken) {
            /*
             * LeaseState: Broken
             * LeaseStatus: Unlocked
             * LeaseDurationType: undefined
             * LeaseExpireTime: undefined
             * LeaseDurationSeconds: undefined
             * LeaseBreakTime: undefined
             * LeaseId: uuid
             */
            if (lease.leaseStatus !== models_1.LeaseStatusType.Unlocked) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Unlocked}.`);
            }
            if (lease.leaseId === undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
            }
            if (lease.leaseExpireTime !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is not undefined.`);
            }
            if (lease.leaseDurationSeconds !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is not undefined.`);
            }
            if (lease.leaseDurationType !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not undefined.`);
            }
            if (lease.leaseBreakTime !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is not undefined.`);
            }
            // Deep copy
            super({ ...lease }, context);
        }
        else if (lease.leaseState === models_1.LeaseStateType.Breaking) {
            /*
             * LeaseState: Breaking
             * LeaseStatus: Locked
             * LeaseDurationType: undefined
             * LeaseExpireTime: undefined
             * LeaseDurationSeconds: undefined
             * LeaseBreakTime: now >= timestamp
             * LeaseId: uuid
             */
            if (lease.leaseStatus !== models_1.LeaseStatusType.Locked) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming lease status ${lease.leaseStatus} is not ${models_1.LeaseStatusType.Locked}.`);
            }
            if (lease.leaseId === undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseId ${lease.leaseId} should not be undefined.`);
            }
            if (lease.leaseExpireTime !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseExpireTime ${lease.leaseExpireTime} is not undefined.`);
            }
            if (lease.leaseDurationSeconds !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseDurationSeconds ${lease.leaseDurationSeconds} is not undefined.`);
            }
            if (lease.leaseDurationType !== undefined) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseDurationType ${lease.leaseDurationType} is not undefined.`);
            }
            if (lease.leaseBreakTime === undefined ||
                context.startTime < lease.leaseBreakTime) {
                throw RangeError(`LeaseBrokenState:constructor() error, incoming leaseBreakTime ${lease.leaseBreakTime} is undefined, or larger than current time ${context.startTime}.`);
            }
            super({
                leaseId: lease.leaseId,
                leaseState: models_1.LeaseStateType.Broken,
                leaseStatus: models_1.LeaseStatusType.Unlocked,
                leaseDurationType: undefined,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, context);
        }
        else {
            throw RangeError(`LeaseBrokenState:constructor() error, incoming lease state ${lease.leaseState} is neither ${models_1.LeaseStateType.Broken} or ${models_1.LeaseStateType.Breaking}.`);
        }
    }
    acquire(duration, proposedLeaseId = "") {
        if ((duration < 15 || duration > 60) && duration !== -1) {
            throw StorageErrorFactory_1.default.getInvalidLeaseDuration(this.context.contextId);
        }
        // TODO: Validate proposedLeaseId follows GUID format
        if (duration === -1) {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Infinite,
                leaseDurationSeconds: undefined,
                leaseExpireTime: undefined,
                leaseBreakTime: undefined
            }, this.context);
        }
        else {
            return new LeaseLeasedState_1.default({
                leaseId: proposedLeaseId || uuid(),
                leaseState: models_1.LeaseStateType.Leased,
                leaseStatus: models_1.LeaseStatusType.Locked,
                leaseDurationType: models_1.LeaseDurationType.Fixed,
                leaseDurationSeconds: duration,
                leaseExpireTime: new Date(this.context.startTime.getTime() + duration * 1000),
                leaseBreakTime: undefined
            }, this.context);
        }
    }
    break(breakPeriod) {
        return this;
    }
    renew(proposedLeaseId) {
        if (proposedLeaseId === this.lease.leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIsBrokenAndCannotBeRenewed(this.context.contextId);
        }
        else {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
    }
    change() {
        throw StorageErrorFactory_1.default.getLeaseNotPresentWithLeaseOperation(this.context.contextId);
    }
    release(leaseId) {
        if (this.lease.leaseId !== leaseId) {
            throw StorageErrorFactory_1.default.getLeaseIdMismatchWithLeaseOperation(this.context.contextId);
        }
        return new LeaseAvailableState_1.default({
            leaseId: undefined,
            leaseState: models_1.LeaseStateType.Available,
            leaseStatus: models_1.LeaseStatusType.Unlocked,
            leaseDurationType: undefined,
            leaseDurationSeconds: undefined,
            leaseExpireTime: undefined,
            leaseBreakTime: undefined
        }, this.context);
    }
}
exports.default = LeaseBrokenState;
//# sourceMappingURL=LeaseBrokenState.js.map