"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const operation_1 = tslib_1.__importDefault(require("../artifacts/operation"));
const specifications_1 = tslib_1.__importDefault(require("../artifacts/specifications"));
const OperationMismatchError_1 = tslib_1.__importDefault(require("../errors/OperationMismatchError"));
const handlerMappers_1 = tslib_1.__importDefault(require("../handlers/handlerMappers"));
/**
 * Auto generated. HandlerMiddlewareFactory will accept handlers and create handler middleware.
 *
 * @export
 * @class HandlerMiddlewareFactory
 */
class HandlerMiddlewareFactory {
    /**
     * Creates an instance of HandlerMiddlewareFactory.
     * Accept handlers and create handler middleware.
     *
     * @param {IHandlers} handlers Handlers implemented handler interfaces
     * @param {ILogger} logger A valid logger
     * @memberof HandlerMiddlewareFactory
     */
    constructor(handlers, logger) {
        this.handlers = handlers;
        this.logger = logger;
    }
    /**
     * Creates a handler middleware from input handlers.
     *
     * @memberof HandlerMiddlewareFactory
     */
    createHandlerMiddleware() {
        return (context, next) => {
            this.logger.info(`HandlerMiddleware: DeserializedParameters=${JSON.stringify(context.handlerParameters, (key, value) => {
                if (key === "body") {
                    return "ReadableStream";
                }
                return value;
            })}`, context.contextId);
            if (context.operation === undefined) {
                const handlerError = new OperationMismatchError_1.default();
                this.logger.error(`HandlerMiddleware: ${handlerError.message}`, context.contextId);
                return next(handlerError);
            }
            if (specifications_1.default[context.operation] === undefined) {
                this.logger.warn(`HandlerMiddleware: cannot find handler for operation ${operation_1.default[context.operation]}`);
            }
            // We assume handlerPath always exists for every generated operation in generated code
            const handlerPath = (0, handlerMappers_1.default)(context.operation);
            const args = [];
            for (const arg of handlerPath.arguments) {
                args.push(context.handlerParameters[arg]);
            }
            args.push(context);
            const handler = this.handlers[handlerPath.handler];
            const handlerMethod = handler[handlerPath.method];
            handlerMethod
                .apply(handler, args)
                .then((response) => {
                context.handlerResponses = response;
            })
                .then(next)
                .catch(next);
        };
    }
}
exports.default = HandlerMiddlewareFactory;
//# sourceMappingURL=HandlerMiddlewareFactory.js.map