"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
// tslint:disable:object-literal-sort-keys
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const msRest = tslib_1.__importStar(require("@azure/ms-rest-js"));
const Mappers = tslib_1.__importStar(require("./mappers"));
const operation_1 = require("./operation");
const Parameters = tslib_1.__importStar(require("./parameters"));
const serializer = new msRest.Serializer(Mappers, true);
// specifications for new method group start
const serviceSetPropertiesOperationSpec = {
    httpMethod: "PUT",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype0,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    requestBody: {
        parameterPath: "storageServiceProperties",
        mapper: {
            ...Mappers.StorageServiceProperties,
            required: true
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        202: {
            headersMapper: Mappers.ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceGetPropertiesOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype0,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.StorageServiceProperties,
            headersMapper: Mappers.ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceGetStatisticsOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype0,
        Parameters.comp1
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.StorageServiceStats,
            headersMapper: Mappers.ServiceGetStatisticsHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceListContainersSegmentOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.include0,
        Parameters.timeout,
        Parameters.comp2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.ListContainersSegmentResponse,
            headersMapper: Mappers.ServiceListContainersSegmentHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceGetUserDelegationKeyOperationSpec = {
    httpMethod: "POST",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype0,
        Parameters.comp3
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    requestBody: {
        parameterPath: "keyInfo",
        mapper: {
            ...Mappers.KeyInfo,
            required: true
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        200: {
            bodyMapper: Mappers.UserDelegationKey,
            headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceGetAccountInfoOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.ServiceGetAccountInfoHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceGetAccountInfoWithHeadOperationSpec = {
    httpMethod: "HEAD",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.ServiceGetAccountInfoWithHeadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceSubmitBatchOperationSpec = {
    httpMethod: "POST",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp4
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.multipartContentType,
        Parameters.version,
        Parameters.requestId
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        202: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.ServiceSubmitBatchHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const serviceFilterBlobsOperationSpec = {
    httpMethod: "GET",
    urlParameters: [
        Parameters.url
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.where,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.include1,
        Parameters.comp5
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.FilterBlobSegment,
            headersMapper: Mappers.ServiceFilterBlobsHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const containerCreateOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.access,
        Parameters.version,
        Parameters.requestId,
        Parameters.defaultEncryptionScope,
        Parameters.preventEncryptionScopeOverride
    ],
    responses: {
        201: {
            headersMapper: Mappers.ContainerCreateHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerGetPropertiesOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerGetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerGetPropertiesWithHeadOperationSpec = {
    httpMethod: "HEAD",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerGetPropertiesWithHeadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerDeleteOperationSpec = {
    httpMethod: "DELETE",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        202: {
            headersMapper: Mappers.ContainerDeleteHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerSetMetadataOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp6
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerSetMetadataHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerGetAccessPolicyOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp7
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0
    ],
    responses: {
        200: {
            bodyMapper: {
                xmlElementName: "SignedIdentifier",
                serializedName: "SignedIdentifiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier"
                        }
                    }
                }
            },
            headersMapper: Mappers.ContainerGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerSetAccessPolicyOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp7
    ],
    headerParameters: [
        Parameters.access,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    requestBody: {
        parameterPath: [
            "options",
            "containerAcl"
        ],
        mapper: {
            xmlName: "SignedIdentifiers",
            xmlElementName: "SignedIdentifier",
            serializedName: "containerAcl",
            type: {
                name: "Sequence",
                element: {
                    type: {
                        name: "Composite",
                        className: "SignedIdentifier"
                    }
                }
            }
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        200: {
            headersMapper: Mappers.ContainerSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerRestoreOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp8
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.deletedContainerName,
        Parameters.deletedContainerVersion
    ],
    responses: {
        201: {
            headersMapper: Mappers.ContainerRestoreHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerSubmitBatchOperationSpec = {
    httpMethod: "POST",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp4
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.multipartContentType,
        Parameters.version,
        Parameters.requestId
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        202: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.ContainerSubmitBatchHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerFilterBlobsOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.where,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.include1,
        Parameters.restype2,
        Parameters.comp5
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.FilterBlobSegment,
            headersMapper: Mappers.ContainerFilterBlobsHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerAcquireLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.duration,
        Parameters.proposedLeaseId0,
        Parameters.version,
        Parameters.requestId,
        Parameters.action0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        201: {
            headersMapper: Mappers.ContainerAcquireLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerReleaseLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerReleaseLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerRenewLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action2,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerRenewLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerBreakLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.breakPeriod,
        Parameters.version,
        Parameters.requestId,
        Parameters.action3,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        202: {
            headersMapper: Mappers.ContainerBreakLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerChangeLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9,
        Parameters.restype2
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.proposedLeaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action4,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerChangeLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerListBlobFlatSegmentOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.include2,
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
            headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerListBlobHierarchySegmentOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.prefix,
        Parameters.delimiter,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.include2,
        Parameters.timeout,
        Parameters.restype2,
        Parameters.comp2
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
            headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerGetAccountInfoOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerGetAccountInfoHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const containerGetAccountInfoWithHeadOperationSpec = {
    httpMethod: "HEAD",
    path: "{containerName}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.ContainerGetAccountInfoWithHeadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const blobDownloadOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.range0,
        Parameters.rangeGetContentMD5,
        Parameters.rangeGetContentCRC64,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.BlobDownloadHeaders
        },
        206: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.BlobDownloadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobGetPropertiesOperationSpec = {
    httpMethod: "HEAD",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobGetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobDeleteOperationSpec = {
    httpMethod: "DELETE",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.timeout,
        Parameters.blobDeleteType
    ],
    headerParameters: [
        Parameters.deleteSnapshots,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        202: {
            headersMapper: Mappers.BlobDeleteHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobUndeleteOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp8
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobUndeleteHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetExpiryOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp10
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.expiryOptions,
        Parameters.expiresOn
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetExpiryHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetHTTPHeadersOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentMD5,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetHTTPHeadersHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetImmutabilityPolicyOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp11
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.ifUnmodifiedSince
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobDeleteImmutabilityPolicyOperationSpec = {
    httpMethod: "DELETE",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp11
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetLegalHoldOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp12
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.legalHold0
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetLegalHoldHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetMetadataOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp6
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetMetadataHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobAcquireLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9
    ],
    headerParameters: [
        Parameters.duration,
        Parameters.proposedLeaseId0,
        Parameters.version,
        Parameters.requestId,
        Parameters.action0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        201: {
            headersMapper: Mappers.BlobAcquireLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobReleaseLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action1,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobReleaseLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobRenewLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action2,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobRenewLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobChangeLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9
    ],
    headerParameters: [
        Parameters.leaseId1,
        Parameters.proposedLeaseId1,
        Parameters.version,
        Parameters.requestId,
        Parameters.action4,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobChangeLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobBreakLeaseOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp9
    ],
    headerParameters: [
        Parameters.breakPeriod,
        Parameters.version,
        Parameters.requestId,
        Parameters.action3,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        202: {
            headersMapper: Mappers.BlobBreakLeaseHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobCreateSnapshotOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp13
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.version,
        Parameters.requestId,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.leaseId0
    ],
    responses: {
        201: {
            headersMapper: Mappers.BlobCreateSnapshotHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobStartCopyFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.tier0,
        Parameters.rehydratePriority,
        Parameters.copySource,
        Parameters.version,
        Parameters.requestId,
        Parameters.blobTagsString,
        Parameters.sealBlob,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceIfTags,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.leaseId0
    ],
    responses: {
        202: {
            headersMapper: Mappers.BlobStartCopyFromURLHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobCopyFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.metadata,
        Parameters.tier0,
        Parameters.copySource,
        Parameters.version,
        Parameters.requestId,
        Parameters.sourceContentMD5,
        Parameters.blobTagsString,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.copySourceAuthorization,
        Parameters.copySourceTags,
        Parameters.xMsRequiresSync,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.leaseId0,
        Parameters.encryptionScope
    ],
    responses: {
        202: {
            headersMapper: Mappers.BlobCopyFromURLHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobAbortCopyFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.copyId,
        Parameters.timeout,
        Parameters.comp14
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.copyActionAbortConstant,
        Parameters.leaseId0
    ],
    responses: {
        204: {
            headersMapper: Mappers.BlobAbortCopyFromURLHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetTierOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.timeout,
        Parameters.comp15
    ],
    headerParameters: [
        Parameters.tier1,
        Parameters.rehydratePriority,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobSetTierHeaders
        },
        202: {
            headersMapper: Mappers.BlobSetTierHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobGetAccountInfoOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobGetAccountInfoHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobGetAccountInfoWithHeadOperationSpec = {
    httpMethod: "HEAD",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.restype1,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.version
    ],
    responses: {
        200: {
            headersMapper: Mappers.BlobGetAccountInfoWithHeadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobQueryOperationSpec = {
    httpMethod: "POST",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.timeout,
        Parameters.comp16
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    requestBody: {
        parameterPath: [
            "options",
            "queryRequest"
        ],
        mapper: Mappers.QueryRequest
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        200: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.BlobQueryHeaders
        },
        206: {
            bodyMapper: {
                serializedName: "Stream",
                type: {
                    name: "Stream"
                }
            },
            headersMapper: Mappers.BlobQueryHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobGetTagsOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.snapshot,
        Parameters.versionId,
        Parameters.comp17
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.ifTags,
        Parameters.leaseId0
    ],
    responses: {
        200: {
            bodyMapper: Mappers.BlobTags,
            headersMapper: Mappers.BlobGetTagsHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blobSetTagsOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.versionId,
        Parameters.comp17
    ],
    headerParameters: [
        Parameters.version,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.requestId,
        Parameters.ifTags,
        Parameters.leaseId0
    ],
    requestBody: {
        parameterPath: [
            "options",
            "tags"
        ],
        mapper: Mappers.BlobTags
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        204: {
            headersMapper: Mappers.BlobSetTagsHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const pageBlobCreateOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.tier0,
        Parameters.metadata,
        Parameters.blobContentLength,
        Parameters.blobSequenceNumber,
        Parameters.version,
        Parameters.requestId,
        Parameters.blobTagsString,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.blobType0,
        Parameters.blobContentType,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentMD5,
        Parameters.blobCacheControl,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        201: {
            headersMapper: Mappers.PageBlobCreateHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobUploadPagesOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp18
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.range0,
        Parameters.version,
        Parameters.requestId,
        Parameters.pageWrite0,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        201: {
            headersMapper: Mappers.PageBlobUploadPagesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobClearPagesOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp18
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.range0,
        Parameters.version,
        Parameters.requestId,
        Parameters.pageWrite1,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        201: {
            headersMapper: Mappers.PageBlobClearPagesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobUploadPagesFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp18
    ],
    headerParameters: [
        Parameters.sourceUrl,
        Parameters.sourceRange0,
        Parameters.sourceContentMD5,
        Parameters.sourceContentcrc64,
        Parameters.contentLength,
        Parameters.range1,
        Parameters.version,
        Parameters.requestId,
        Parameters.copySourceAuthorization,
        Parameters.pageWrite0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.leaseId0,
        Parameters.ifSequenceNumberLessThanOrEqualTo,
        Parameters.ifSequenceNumberLessThan,
        Parameters.ifSequenceNumberEqualTo,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch
    ],
    responses: {
        201: {
            headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobGetPageRangesOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.timeout,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.comp19
    ],
    headerParameters: [
        Parameters.range0,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            bodyMapper: Mappers.PageList,
            headersMapper: Mappers.PageBlobGetPageRangesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobGetPageRangesDiffOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.timeout,
        Parameters.prevsnapshot,
        Parameters.marker,
        Parameters.maxresults,
        Parameters.comp19
    ],
    headerParameters: [
        Parameters.prevSnapshotUrl,
        Parameters.range0,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            bodyMapper: Mappers.PageList,
            headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobResizeOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.blobContentLength,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.PageBlobResizeHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobUpdateSequenceNumberOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp0
    ],
    headerParameters: [
        Parameters.sequenceNumberAction,
        Parameters.blobSequenceNumber,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        200: {
            headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const pageBlobCopyIncrementalOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp20
    ],
    headerParameters: [
        Parameters.copySource,
        Parameters.version,
        Parameters.requestId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        202: {
            headersMapper: Mappers.PageBlobCopyIncrementalHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const appendBlobCreateOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.version,
        Parameters.requestId,
        Parameters.blobTagsString,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.blobType1,
        Parameters.blobContentType,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentMD5,
        Parameters.blobCacheControl,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    responses: {
        201: {
            headersMapper: Mappers.AppendBlobCreateHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const appendBlobAppendBlockOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp21
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.maxSize,
        Parameters.appendPosition,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        201: {
            headersMapper: Mappers.AppendBlobAppendBlockHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const appendBlobAppendBlockFromUrlOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp21
    ],
    headerParameters: [
        Parameters.sourceUrl,
        Parameters.sourceRange1,
        Parameters.sourceContentMD5,
        Parameters.sourceContentcrc64,
        Parameters.contentLength,
        Parameters.transactionalContentMD5,
        Parameters.version,
        Parameters.requestId,
        Parameters.copySourceAuthorization,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.leaseId0,
        Parameters.maxSize,
        Parameters.appendPosition,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch
    ],
    responses: {
        201: {
            headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const appendBlobSealOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp22
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.appendPosition
    ],
    responses: {
        200: {
            headersMapper: Mappers.AppendBlobSealHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
// specifications for new method group start
const blockBlobUploadOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.transactionalContentMD5,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.tier0,
        Parameters.version,
        Parameters.requestId,
        Parameters.blobTagsString,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.transactionalContentCrc64,
        Parameters.blobType2,
        Parameters.blobContentType,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentMD5,
        Parameters.blobCacheControl,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        201: {
            headersMapper: Mappers.BlockBlobUploadHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blockBlobPutBlobFromUrlOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout
    ],
    headerParameters: [
        Parameters.transactionalContentMD5,
        Parameters.contentLength,
        Parameters.metadata,
        Parameters.tier0,
        Parameters.version,
        Parameters.requestId,
        Parameters.sourceContentMD5,
        Parameters.blobTagsString,
        Parameters.copySource,
        Parameters.copySourceBlobProperties,
        Parameters.copySourceAuthorization,
        Parameters.copySourceTags,
        Parameters.blobType2,
        Parameters.blobContentType,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentMD5,
        Parameters.blobCacheControl,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch,
        Parameters.sourceIfTags
    ],
    responses: {
        201: {
            headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blockBlobStageBlockOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.blockId,
        Parameters.timeout,
        Parameters.comp23
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope
    ],
    requestBody: {
        parameterPath: "body",
        mapper: {
            required: true,
            serializedName: "body",
            type: {
                name: "Stream"
            }
        }
    },
    contentType: "application/octet-stream",
    responses: {
        201: {
            headersMapper: Mappers.BlockBlobStageBlockHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blockBlobStageBlockFromURLOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.blockId,
        Parameters.timeout,
        Parameters.comp23
    ],
    headerParameters: [
        Parameters.contentLength,
        Parameters.sourceUrl,
        Parameters.sourceRange1,
        Parameters.sourceContentMD5,
        Parameters.sourceContentcrc64,
        Parameters.version,
        Parameters.requestId,
        Parameters.copySourceAuthorization,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.leaseId0,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch
    ],
    responses: {
        201: {
            headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blockBlobCommitBlockListOperationSpec = {
    httpMethod: "PUT",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.timeout,
        Parameters.comp24
    ],
    headerParameters: [
        Parameters.transactionalContentMD5,
        Parameters.transactionalContentCrc64,
        Parameters.metadata,
        Parameters.tier0,
        Parameters.version,
        Parameters.requestId,
        Parameters.blobTagsString,
        Parameters.immutabilityPolicyExpiry,
        Parameters.immutabilityPolicyMode,
        Parameters.legalHold1,
        Parameters.blobCacheControl,
        Parameters.blobContentType,
        Parameters.blobContentEncoding,
        Parameters.blobContentLanguage,
        Parameters.blobContentMD5,
        Parameters.blobContentDisposition,
        Parameters.leaseId0,
        Parameters.encryptionKey,
        Parameters.encryptionKeySha256,
        Parameters.encryptionAlgorithm,
        Parameters.encryptionScope,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.ifTags
    ],
    requestBody: {
        parameterPath: "blocks",
        mapper: {
            ...Mappers.BlockLookupList,
            required: true
        }
    },
    contentType: "application/xml; charset=utf-8",
    responses: {
        201: {
            headersMapper: Mappers.BlockBlobCommitBlockListHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const blockBlobGetBlockListOperationSpec = {
    httpMethod: "GET",
    path: "{containerName}/{blob}",
    urlParameters: [
        Parameters.url,
        Parameters.containerName,
        Parameters.blob
    ],
    queryParameters: [
        Parameters.snapshot,
        Parameters.listType,
        Parameters.timeout,
        Parameters.comp24
    ],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.leaseId0,
        Parameters.ifTags
    ],
    responses: {
        200: {
            bodyMapper: Mappers.BlockList,
            headersMapper: Mappers.BlockBlobGetBlockListHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError
        }
    },
    isXML: true,
    serializer
};
const Specifications = {};
Specifications[operation_1.Operation.Service_SetProperties] = serviceSetPropertiesOperationSpec;
Specifications[operation_1.Operation.Service_GetProperties] = serviceGetPropertiesOperationSpec;
Specifications[operation_1.Operation.Service_GetStatistics] = serviceGetStatisticsOperationSpec;
Specifications[operation_1.Operation.Service_ListContainersSegment] = serviceListContainersSegmentOperationSpec;
Specifications[operation_1.Operation.Service_GetUserDelegationKey] = serviceGetUserDelegationKeyOperationSpec;
Specifications[operation_1.Operation.Service_GetAccountInfo] = serviceGetAccountInfoOperationSpec;
Specifications[operation_1.Operation.Service_GetAccountInfoWithHead] = serviceGetAccountInfoWithHeadOperationSpec;
Specifications[operation_1.Operation.Service_SubmitBatch] = serviceSubmitBatchOperationSpec;
Specifications[operation_1.Operation.Service_FilterBlobs] = serviceFilterBlobsOperationSpec;
Specifications[operation_1.Operation.Container_Create] = containerCreateOperationSpec;
Specifications[operation_1.Operation.Container_GetProperties] = containerGetPropertiesOperationSpec;
Specifications[operation_1.Operation.Container_GetPropertiesWithHead] = containerGetPropertiesWithHeadOperationSpec;
Specifications[operation_1.Operation.Container_Delete] = containerDeleteOperationSpec;
Specifications[operation_1.Operation.Container_SetMetadata] = containerSetMetadataOperationSpec;
Specifications[operation_1.Operation.Container_GetAccessPolicy] = containerGetAccessPolicyOperationSpec;
Specifications[operation_1.Operation.Container_SetAccessPolicy] = containerSetAccessPolicyOperationSpec;
Specifications[operation_1.Operation.Container_Restore] = containerRestoreOperationSpec;
Specifications[operation_1.Operation.Container_SubmitBatch] = containerSubmitBatchOperationSpec;
Specifications[operation_1.Operation.Container_FilterBlobs] = containerFilterBlobsOperationSpec;
Specifications[operation_1.Operation.Container_AcquireLease] = containerAcquireLeaseOperationSpec;
Specifications[operation_1.Operation.Container_ReleaseLease] = containerReleaseLeaseOperationSpec;
Specifications[operation_1.Operation.Container_RenewLease] = containerRenewLeaseOperationSpec;
Specifications[operation_1.Operation.Container_BreakLease] = containerBreakLeaseOperationSpec;
Specifications[operation_1.Operation.Container_ChangeLease] = containerChangeLeaseOperationSpec;
Specifications[operation_1.Operation.Container_ListBlobFlatSegment] = containerListBlobFlatSegmentOperationSpec;
Specifications[operation_1.Operation.Container_ListBlobHierarchySegment] = containerListBlobHierarchySegmentOperationSpec;
Specifications[operation_1.Operation.Container_GetAccountInfo] = containerGetAccountInfoOperationSpec;
Specifications[operation_1.Operation.Container_GetAccountInfoWithHead] = containerGetAccountInfoWithHeadOperationSpec;
Specifications[operation_1.Operation.Blob_Download] = blobDownloadOperationSpec;
Specifications[operation_1.Operation.Blob_GetProperties] = blobGetPropertiesOperationSpec;
Specifications[operation_1.Operation.Blob_Delete] = blobDeleteOperationSpec;
Specifications[operation_1.Operation.Blob_Undelete] = blobUndeleteOperationSpec;
Specifications[operation_1.Operation.Blob_SetExpiry] = blobSetExpiryOperationSpec;
Specifications[operation_1.Operation.Blob_SetHTTPHeaders] = blobSetHTTPHeadersOperationSpec;
Specifications[operation_1.Operation.Blob_SetImmutabilityPolicy] = blobSetImmutabilityPolicyOperationSpec;
Specifications[operation_1.Operation.Blob_DeleteImmutabilityPolicy] = blobDeleteImmutabilityPolicyOperationSpec;
Specifications[operation_1.Operation.Blob_SetLegalHold] = blobSetLegalHoldOperationSpec;
Specifications[operation_1.Operation.Blob_SetMetadata] = blobSetMetadataOperationSpec;
Specifications[operation_1.Operation.Blob_AcquireLease] = blobAcquireLeaseOperationSpec;
Specifications[operation_1.Operation.Blob_ReleaseLease] = blobReleaseLeaseOperationSpec;
Specifications[operation_1.Operation.Blob_RenewLease] = blobRenewLeaseOperationSpec;
Specifications[operation_1.Operation.Blob_ChangeLease] = blobChangeLeaseOperationSpec;
Specifications[operation_1.Operation.Blob_BreakLease] = blobBreakLeaseOperationSpec;
Specifications[operation_1.Operation.Blob_CreateSnapshot] = blobCreateSnapshotOperationSpec;
Specifications[operation_1.Operation.Blob_StartCopyFromURL] = blobStartCopyFromURLOperationSpec;
Specifications[operation_1.Operation.Blob_CopyFromURL] = blobCopyFromURLOperationSpec;
Specifications[operation_1.Operation.Blob_AbortCopyFromURL] = blobAbortCopyFromURLOperationSpec;
Specifications[operation_1.Operation.Blob_SetTier] = blobSetTierOperationSpec;
Specifications[operation_1.Operation.Blob_GetAccountInfo] = blobGetAccountInfoOperationSpec;
Specifications[operation_1.Operation.Blob_GetAccountInfoWithHead] = blobGetAccountInfoWithHeadOperationSpec;
Specifications[operation_1.Operation.Blob_Query] = blobQueryOperationSpec;
Specifications[operation_1.Operation.Blob_GetTags] = blobGetTagsOperationSpec;
Specifications[operation_1.Operation.Blob_SetTags] = blobSetTagsOperationSpec;
Specifications[operation_1.Operation.PageBlob_Create] = pageBlobCreateOperationSpec;
Specifications[operation_1.Operation.PageBlob_UploadPages] = pageBlobUploadPagesOperationSpec;
Specifications[operation_1.Operation.PageBlob_ClearPages] = pageBlobClearPagesOperationSpec;
Specifications[operation_1.Operation.PageBlob_UploadPagesFromURL] = pageBlobUploadPagesFromURLOperationSpec;
Specifications[operation_1.Operation.PageBlob_GetPageRanges] = pageBlobGetPageRangesOperationSpec;
Specifications[operation_1.Operation.PageBlob_GetPageRangesDiff] = pageBlobGetPageRangesDiffOperationSpec;
Specifications[operation_1.Operation.PageBlob_Resize] = pageBlobResizeOperationSpec;
Specifications[operation_1.Operation.PageBlob_UpdateSequenceNumber] = pageBlobUpdateSequenceNumberOperationSpec;
Specifications[operation_1.Operation.PageBlob_CopyIncremental] = pageBlobCopyIncrementalOperationSpec;
Specifications[operation_1.Operation.AppendBlob_Create] = appendBlobCreateOperationSpec;
Specifications[operation_1.Operation.AppendBlob_AppendBlock] = appendBlobAppendBlockOperationSpec;
Specifications[operation_1.Operation.AppendBlob_AppendBlockFromUrl] = appendBlobAppendBlockFromUrlOperationSpec;
Specifications[operation_1.Operation.AppendBlob_Seal] = appendBlobSealOperationSpec;
Specifications[operation_1.Operation.BlockBlob_Upload] = blockBlobUploadOperationSpec;
Specifications[operation_1.Operation.BlockBlob_PutBlobFromUrl] = blockBlobPutBlobFromUrlOperationSpec;
Specifications[operation_1.Operation.BlockBlob_StageBlock] = blockBlobStageBlockOperationSpec;
Specifications[operation_1.Operation.BlockBlob_StageBlockFromURL] = blockBlobStageBlockFromURLOperationSpec;
Specifications[operation_1.Operation.BlockBlob_CommitBlockList] = blockBlobCommitBlockListOperationSpec;
Specifications[operation_1.Operation.BlockBlob_GetBlockList] = blockBlobGetBlockListOperationSpec;
exports.default = Specifications;
//# sourceMappingURL=specifications.js.map