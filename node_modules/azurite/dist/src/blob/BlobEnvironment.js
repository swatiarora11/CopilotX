"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const args_1 = tslib_1.__importDefault(require("args"));
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const constants_1 = require("./utils/constants");
if (!args_1.default.config.name) {
    args_1.default
        .option(["", "blobHost"], "Optional. Customize listening address for blob", constants_1.DEFAULT_BLOB_SERVER_HOST_NAME)
        .option(["", "blobPort"], "Optional. Customize listening port for blob", constants_1.DEFAULT_BLOB_LISTENING_PORT)
        .option(["l", "location"], "Optional. Use an existing folder as workspace path, default is current working directory", "<cwd>", s => s == "<cwd>" ? undefined : s)
        .option(["s", "silent"], "Optional. Disable access log displayed in console")
        .option(["L", "loose"], "Optional. Enable loose mode which ignores unsupported headers and parameters")
        .option(["", "skipApiVersionCheck"], "Optional. Skip the request API version check, request with all Api versions will be allowed")
        .option(["", "oauth"], 'Optional. OAuth level. Candidate values: "basic"')
        .option(["", "cert"], "Optional. Path to certificate file")
        .option(["", "key"], "Optional. Path to certificate key .pem file")
        .option(["", "inMemoryPersistence"], "Optional. Disable persisting any data to disk. If the Azurite process is terminated, all data is lost")
        .option(["", "extentMemoryLimit"], "Optional. The number of megabytes to limit in-memory extent storage to. Only used with the --inMemoryPersistence option. Defaults to 50% of total memory", -1, s => s == -1 ? undefined : parseFloat(s))
        .option(["d", "debug"], "Optional. Enable debug log by providing a valid local file path as log destination")
        .option(["", "pwd"], "Optional. Password for .pfx file")
        .option(["", "disableProductStyleUrl"], "Optional. Disable getting account name from the host of request Uri, always get account name from the first path segment of request Uri.");
    args_1.default.config.name = "azurite-blob";
}
class BlobEnvironment {
    constructor() {
        this.flags = args_1.default.parse(process.argv);
    }
    blobHost() {
        return this.flags.blobHost;
    }
    blobPort() {
        return this.flags.blobPort;
    }
    async location() {
        const location = this.flags.location || process.cwd();
        await (0, fs_extra_1.ensureDir)(location);
        await (0, fs_extra_1.access)(location);
        return location;
    }
    silent() {
        if (this.flags.silent !== undefined) {
            return true;
        }
        return false;
    }
    loose() {
        if (this.flags.loose !== undefined) {
            return true;
        }
        // default is false which will block not supported APIs, headers and parameters
        return false;
    }
    skipApiVersionCheck() {
        if (this.flags.skipApiVersionCheck !== undefined) {
            return true;
        }
        // default is false which will check API veresion
        return false;
    }
    cert() {
        return this.flags.cert;
    }
    key() {
        return this.flags.key;
    }
    pwd() {
        return this.flags.pwd;
    }
    oauth() {
        return this.flags.oauth;
    }
    disableProductStyleUrl() {
        if (this.flags.disableProductStyleUrl !== undefined) {
            return true;
        }
        // default is false which will try to get account name from request Uri hostname
        return false;
    }
    inMemoryPersistence() {
        if (this.flags.inMemoryPersistence !== undefined) {
            if (this.flags.location) {
                throw new RangeError(`The --inMemoryPersistence option is not supported when the --location option is set.`);
            }
            return true;
        }
        else {
            if (this.extentMemoryLimit() !== undefined) {
                throw new RangeError(`The --extentMemoryLimit option is only supported when the --inMemoryPersistence option is set.`);
            }
        }
        return false;
    }
    extentMemoryLimit() {
        return this.flags.extentMemoryLimit;
    }
    async debug() {
        if (typeof this.flags.debug === "string") {
            // Enable debug log to file
            const debugFilePath = this.flags.debug;
            await (0, fs_extra_1.ensureDir)((0, path_1.dirname)(debugFilePath));
            await (0, fs_extra_1.access)((0, path_1.dirname)(debugFilePath));
            return debugFilePath;
        }
        if (this.flags.debug === true) {
            throw RangeError(`Must provide a debug log file path for parameter -d or --debug`);
        }
        // By default disable debug log
    }
}
exports.default = BlobEnvironment;
//# sourceMappingURL=BlobEnvironment.js.map