#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
// Load Environment before BlobServerFactory to make sure args works properly
const Environment_1 = tslib_1.__importDefault(require("./common/Environment"));
// tslint:disable-next-line:ordered-imports
const BlobServerFactory_1 = require("./blob/BlobServerFactory");
const Logger = tslib_1.__importStar(require("./common/Logger"));
const QueueConfiguration_1 = tslib_1.__importDefault(require("./queue/QueueConfiguration"));
const QueueServer_1 = tslib_1.__importDefault(require("./queue/QueueServer"));
const constants_1 = require("./queue/utils/constants");
const TableConfiguration_1 = tslib_1.__importDefault(require("./table/TableConfiguration"));
const TableServer_1 = tslib_1.__importDefault(require("./table/TableServer"));
const constants_2 = require("./table/utils/constants");
const ConfigurationBase_1 = require("./common/ConfigurationBase");
// tslint:disable:no-console
function shutdown(blobServer, queueServer, tableServer) {
    const blobBeforeCloseMessage = `Azurite Blob service is closing...`;
    const blobAfterCloseMessage = `Azurite Blob service successfully closed`;
    const queueBeforeCloseMessage = `Azurite Queue service is closing...`;
    const queueAfterCloseMessage = `Azurite Queue service successfully closed`;
    const tableBeforeCloseMessage = `Azurite Table service is closing...`;
    const tableAfterCloseMessage = `Azurite Table service successfully closed`;
    console.log(blobBeforeCloseMessage);
    blobServer.close().then(() => {
        console.log(blobAfterCloseMessage);
    });
    console.log(queueBeforeCloseMessage);
    queueServer.close().then(() => {
        console.log(queueAfterCloseMessage);
    });
    console.log(tableBeforeCloseMessage);
    tableServer.close().then(() => {
        console.log(tableAfterCloseMessage);
    });
}
/**
 * Entry for Azurite services.
 */
async function main() {
    // Initialize and validate environment values from command line parameters
    const env = new Environment_1.default();
    const location = await env.location();
    await (0, fs_extra_1.ensureDir)(location);
    await (0, fs_extra_1.access)(location);
    const debugFilePath = await env.debug();
    if (debugFilePath !== undefined) {
        await (0, fs_extra_1.ensureDir)((0, path_1.dirname)(debugFilePath));
        await (0, fs_extra_1.access)((0, path_1.dirname)(debugFilePath));
    }
    const blobServerFactory = new BlobServerFactory_1.BlobServerFactory();
    const blobServer = await blobServerFactory.createServer(env);
    const blobConfig = blobServer.config;
    // TODO: Align with blob DEFAULT_BLOB_PERSISTENCE_ARRAY
    // TODO: Join for all paths in the array
    constants_1.DEFAULT_QUEUE_PERSISTENCE_ARRAY[0].locationPath = (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_PERSISTENCE_PATH);
    const queueConfig = new QueueConfiguration_1.default(env.queueHost(), env.queuePort(), (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_LOKI_DB_PATH), (0, path_1.join)(location, constants_1.DEFAULT_QUEUE_EXTENT_LOKI_DB_PATH), constants_1.DEFAULT_QUEUE_PERSISTENCE_ARRAY, !env.silent(), undefined, env.debug() !== undefined, await env.debug(), env.loose(), env.skipApiVersionCheck(), env.cert(), env.key(), env.pwd(), env.oauth(), env.disableProductStyleUrl(), env.inMemoryPersistence());
    const tableConfig = new TableConfiguration_1.default(env.tableHost(), env.tablePort(), (0, path_1.join)(location, constants_2.DEFAULT_TABLE_LOKI_DB_PATH), env.debug() !== undefined, !env.silent(), undefined, await env.debug(), env.loose(), env.skipApiVersionCheck(), env.cert(), env.key(), env.pwd(), env.oauth(), env.disableProductStyleUrl(), env.inMemoryPersistence());
    // We use logger singleton as global debugger logger to track detailed outputs cross layers
    // Note that, debug log is different from access log which is only available in request handler layer to
    // track every request. Access log is not singleton, and initialized in specific RequestHandlerFactory implementations
    // Enable debug log by default before first release for debugging purpose
    Logger.configLogger(blobConfig.enableDebugLog, blobConfig.debugLogFilePath);
    // Create queue server instance
    const queueServer = new QueueServer_1.default(queueConfig);
    // Create table server instance
    const tableServer = new TableServer_1.default(tableConfig);
    (0, ConfigurationBase_1.setExtentMemoryLimit)(env, true);
    // Start server
    console.log(`Azurite Blob service is starting at ${blobConfig.getHttpServerAddress()}`);
    await blobServer.start();
    console.log(`Azurite Blob service is successfully listening at ${blobServer.getHttpServerAddress()}`);
    // Start server
    console.log(`Azurite Queue service is starting at ${queueConfig.getHttpServerAddress()}`);
    await queueServer.start();
    console.log(`Azurite Queue service is successfully listening at ${queueServer.getHttpServerAddress()}`);
    // Start server
    console.log(`Azurite Table service is starting at ${tableConfig.getHttpServerAddress()}`);
    await tableServer.start();
    console.log(`Azurite Table service is successfully listening at ${tableServer.getHttpServerAddress()}`);
    // Handle close event
    process
        .once("message", (msg) => {
        if (msg === "shutdown") {
            shutdown(blobServer, queueServer, tableServer);
        }
    })
        .once("SIGINT", () => shutdown(blobServer, queueServer, tableServer))
        .once("SIGTERM", () => shutdown(blobServer, queueServer, tableServer));
}
main().catch((err) => {
    console.error(`Exit due to unhandled error: ${err.message}`);
    process.exit(1);
});
//# sourceMappingURL=azurite.js.map