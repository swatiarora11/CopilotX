"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const VSCServerManagerCleaningState_1 = tslib_1.__importDefault(require("./VSCServerManagerCleaningState"));
const VSCServerManagerClosingState_1 = tslib_1.__importDefault(require("./VSCServerManagerClosingState"));
const VSCServerManagerStartingState_1 = require("./VSCServerManagerStartingState");
class VSCServerManagerBase {
    constructor(name, state, server) {
        this.name = name;
        this.state = state;
        this.server = server;
        this.handlers = [];
        this.startSession = 0;
        this.closeSession = 0;
        this.cleanSession = 0;
    }
    getStartCommand() {
        throw Error("Should implemented in children class.");
    }
    getCloseCommand() {
        throw Error("Should implemented in children class.");
    }
    getCleanCommand() {
        throw Error("Should implemented in children class.");
    }
    addEventListener(handler) {
        this.handlers.push(handler);
    }
    getServer() {
        return this.server;
    }
    async start() {
        this.startSession++;
        const previousState = this.state;
        this.state = new VSCServerManagerStartingState_1.VSCServerManagerStartingState();
        try {
            this.onStart(this.startSession);
            this.state = await previousState.start(this);
            this.onStartSuccess(this.startSession);
        }
        catch (err) {
            this.state = previousState;
            this.onStartFail(this.startSession, err);
        }
    }
    async close() {
        this.closeSession++;
        const previousState = this.state;
        this.state = new VSCServerManagerClosingState_1.default();
        try {
            this.onClose(this.closeSession);
            this.state = await previousState.close(this);
            this.onCloseSuccess(this.closeSession);
        }
        catch (err) {
            this.state = previousState;
            this.onCloseFail(this.closeSession, err);
        }
    }
    async clean() {
        this.cleanSession++;
        const previousState = this.state;
        this.state = new VSCServerManagerCleaningState_1.default();
        try {
            this.onClean(this.cleanSession);
            this.state = await previousState.clean(this);
            this.onCleanSuccess(this.cleanSession);
        }
        catch (err) {
            this.state = previousState;
            this.onCleanFail(this.cleanSession, err);
        }
    }
    onStart(session) {
        for (const handler of this.handlers) {
            try {
                handler.onStart(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onStartFail(session, error) {
        for (const handler of this.handlers) {
            try {
                handler.onStartFail(this, session, error);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onStartSuccess(session) {
        for (const handler of this.handlers) {
            try {
                handler.onStartSuccess(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onClean(session) {
        for (const handler of this.handlers) {
            try {
                handler.onClean(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onCleanFail(session, error) {
        for (const handler of this.handlers) {
            try {
                handler.onCleanFail(this, session, error);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onCleanSuccess(session) {
        for (const handler of this.handlers) {
            try {
                handler.onCleanSuccess(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onClose(session) {
        for (const handler of this.handlers) {
            try {
                handler.onClose(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onCloseFail(session, error) {
        for (const handler of this.handlers) {
            try {
                handler.onCloseFail(this, session, error);
            }
            catch {
                /* NOOP */
            }
        }
    }
    onCloseSuccess(session) {
        for (const handler of this.handlers) {
            try {
                handler.onCloseSuccess(this, session);
            }
            catch {
                /* NOOP */
            }
        }
    }
}
exports.default = VSCServerManagerBase;
//# sourceMappingURL=VSCServerManagerBase.js.map