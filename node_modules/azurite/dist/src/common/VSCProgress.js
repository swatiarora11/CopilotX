"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const vscode_1 = require("vscode");
class VSCProgress extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.START_SUCCESS = "startSuccess_";
        this.START_FAIL = "startFail_";
        this.CLEAN_SUCCESS = "cleanSuccess_";
        this.CLEAN_FAIL = "cleanFail_";
        this.CLOSE_SUCCESS = "closeSuccess_";
        this.CLOSE_FAIL = "closeFail_";
    }
    onStart(serverManager, session) {
        vscode_1.window.withProgress({
            location: vscode_1.ProgressLocation.Notification,
            title: `Starting ${serverManager.name}`
        }, (progress) => {
            progress.report({
                increment: 5,
                message: `${serverManager.name} is starting...`
            });
            return new Promise((resolve, reject) => {
                const resolveCallback = () => {
                    this.removeListener(this.START_SUCCESS + session, resolveCallback);
                    this.removeListener(this.START_FAIL + session, rejectCallback);
                    resolve();
                };
                const rejectCallback = () => {
                    this.removeListener(this.START_SUCCESS + session, resolveCallback);
                    this.removeListener(this.START_FAIL + session, rejectCallback);
                    reject();
                };
                this.once(this.START_SUCCESS + session, resolveCallback);
                this.once(this.START_FAIL + session, rejectCallback);
            });
        });
    }
    onStartFail(serverManager, session, error) {
        this.emit(this.START_FAIL + session, error);
    }
    onStartSuccess(serverManager, session) {
        this.emit(this.START_SUCCESS + session);
    }
    onClean(serverManager, session) {
        vscode_1.window.withProgress({
            location: vscode_1.ProgressLocation.Notification,
            title: `Cleaning ${serverManager.name}`
        }, (progress) => {
            progress.report({
                increment: 5,
                message: `${serverManager.name} is cleaning`
            });
            return new Promise((resolve, reject) => {
                const resolveCallback = () => {
                    this.removeListener(this.CLEAN_SUCCESS + session, resolveCallback);
                    this.removeListener(this.CLEAN_FAIL + session, rejectCallback);
                    resolve();
                };
                const rejectCallback = () => {
                    this.removeListener(this.CLEAN_SUCCESS + session, resolveCallback);
                    this.removeListener(this.CLEAN_FAIL + session, rejectCallback);
                    reject();
                };
                this.once(this.CLEAN_SUCCESS + session, resolveCallback);
                this.once(this.CLEAN_FAIL + session, rejectCallback);
            });
        });
    }
    onCleanFail(serverManager, session, error) {
        this.emit(this.CLEAN_FAIL + session, error);
    }
    onCleanSuccess(serverManager, session) {
        this.emit(this.CLEAN_SUCCESS + session);
    }
    onClose(serverManager, session) {
        vscode_1.window.withProgress({
            location: vscode_1.ProgressLocation.Notification,
            title: `Closing ${serverManager.name}`
        }, (progress) => {
            progress.report({
                increment: 5,
                message: `${serverManager.name} is closing`
            });
            return new Promise((resolve, reject) => {
                const resolveCallback = () => {
                    this.removeListener(this.CLOSE_SUCCESS + session, resolveCallback);
                    this.removeListener(this.CLOSE_FAIL + session, rejectCallback);
                    resolve();
                };
                const rejectCallback = () => {
                    this.removeListener(this.CLOSE_SUCCESS + session, resolveCallback);
                    this.removeListener(this.CLOSE_FAIL + session, rejectCallback);
                    reject();
                };
                this.once(this.CLOSE_SUCCESS + session, resolveCallback);
                this.once(this.CLOSE_FAIL + session, rejectCallback);
            });
        });
    }
    onCloseFail(serverManager, session, error) {
        this.emit(this.CLOSE_FAIL + session, error);
    }
    onCloseSuccess(serverManager, session) {
        this.emit(this.CLOSE_SUCCESS + session);
    }
}
exports.default = VSCProgress;
//# sourceMappingURL=VSCProgress.js.map