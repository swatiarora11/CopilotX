"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configLogger = exports.Logger = void 0;
const tslib_1 = require("tslib");
const ILoggerStrategy_1 = require("./ILoggerStrategy");
const NoLoggerStrategy_1 = tslib_1.__importDefault(require("./NoLoggerStrategy"));
const WinstonLoggerStrategy_1 = tslib_1.__importDefault(require("./WinstonLoggerStrategy"));
class Logger {
    constructor(strategy) {
        this.strategy = strategy;
    }
    error(message, contextID) {
        this.strategy.log(ILoggerStrategy_1.LogLevels.Error, message, contextID);
    }
    warn(message, contextID) {
        this.strategy.log(ILoggerStrategy_1.LogLevels.Warn, message, contextID);
    }
    info(message, contextID) {
        this.strategy.log(ILoggerStrategy_1.LogLevels.Info, message, contextID);
    }
    verbose(message, contextID) {
        this.strategy.log(ILoggerStrategy_1.LogLevels.Verbose, message, contextID);
    }
    debug(message, contextID) {
        this.strategy.log(ILoggerStrategy_1.LogLevels.Debug, message, contextID);
    }
}
exports.Logger = Logger;
// A singleton logger instance
// Could customized logger strategy by assigning a new logger.strategy
// Default NoLoggerStrategy will be used
// Config Logger with WinstonLoggerStrategy will display all levels logs to console STD
const logger = new Logger(new NoLoggerStrategy_1.default());
/**
 * Config global singleton logger instance.
 *
 * @export
 * @param {boolean} enable
 * @param {string} [logFile]
 */
function configLogger(enable, logFile) {
    if (enable) {
        logger.strategy = new WinstonLoggerStrategy_1.default(ILoggerStrategy_1.LogLevels.Debug, logFile);
    }
    else {
        logger.strategy = new NoLoggerStrategy_1.default();
    }
}
exports.configLogger = configLogger;
exports.default = logger;
//# sourceMappingURL=Logger.js.map