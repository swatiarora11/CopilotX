"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const args_1 = tslib_1.__importDefault(require("args"));
const constants_1 = require("../blob/utils/constants");
const constants_2 = require("../queue/utils/constants");
const constants_3 = require("../table/utils/constants");
args_1.default
    .option(["", "blobHost"], "Optional. Customize listening address for blob", constants_1.DEFAULT_BLOB_SERVER_HOST_NAME)
    .option(["", "blobPort"], "Optional. Customize listening port for blob", constants_1.DEFAULT_BLOB_LISTENING_PORT)
    .option(["", "queueHost"], "Optional. Customize listening address for queue", constants_2.DEFAULT_QUEUE_SERVER_HOST_NAME)
    .option(["", "queuePort"], "Optional. Customize listening port for queue", constants_2.DEFAULT_QUEUE_LISTENING_PORT)
    .option(["", "tableHost"], "Optional. Customize listening address for table", constants_3.DEFAULT_TABLE_SERVER_HOST_NAME)
    .option(["", "tablePort"], "Optional. Customize listening port for table", constants_3.DEFAULT_TABLE_LISTENING_PORT)
    .option(["l", "location"], "Optional. Use an existing folder as workspace path, default is current working directory", "<cwd>", s => s == "<cwd>" ? undefined : s)
    .option(["s", "silent"], "Optional. Disable access log displayed in console")
    .option(["L", "loose"], "Optional. Enable loose mode which ignores unsupported headers and parameters")
    .option(["", "skipApiVersionCheck"], "Optional. Skip the request API version check, request with all Api versions will be allowed")
    .option(["", "disableProductStyleUrl"], "Optional. Disable getting account name from the host of request Uri, always get account name from the first path segment of request Uri")
    .option(["", "oauth"], 'Optional. OAuth level. Candidate values: "basic"')
    .option(["", "cert"], "Optional. Path to certificate file")
    .option(["", "key"], "Optional. Path to certificate key .pem file")
    .option(["", "pwd"], "Optional. Password for .pfx file")
    .option(["", "inMemoryPersistence"], "Optional. Disable persisting any data to disk. If the Azurite process is terminated, all data is lost")
    .option(["", "extentMemoryLimit"], "Optional. The number of megabytes to limit in-memory extent storage to. Only used with the --inMemoryPersistence option. Defaults to 50% of total memory", -1, s => s == -1 ? undefined : parseFloat(s))
    .option(["d", "debug"], "Optional. Enable debug log by providing a valid local file path as log destination");
args_1.default.config.name = "azurite";
class Environment {
    constructor() {
        this.flags = args_1.default.parse(process.argv);
    }
    blobHost() {
        return this.flags.blobHost;
    }
    blobPort() {
        return this.flags.blobPort;
    }
    queueHost() {
        return this.flags.queueHost;
    }
    queuePort() {
        return this.flags.queuePort;
    }
    tableHost() {
        return this.flags.tableHost;
    }
    tablePort() {
        return this.flags.tablePort;
    }
    async location() {
        return this.flags.location || process.cwd();
    }
    silent() {
        if (this.flags.silent !== undefined) {
            return true;
        }
        return false;
    }
    loose() {
        if (this.flags.loose !== undefined) {
            return true;
        }
        // default is false which will block not supported APIs, headers and parameters
        return false;
    }
    skipApiVersionCheck() {
        if (this.flags.skipApiVersionCheck !== undefined) {
            return true;
        }
        // default is false which will check API veresion
        return false;
    }
    disableProductStyleUrl() {
        if (this.flags.disableProductStyleUrl !== undefined) {
            return true;
        }
        // default is false which will try to get account name from request Uri hostname
        return false;
    }
    cert() {
        return this.flags.cert;
    }
    key() {
        return this.flags.key;
    }
    pwd() {
        return this.flags.pwd;
    }
    oauth() {
        return this.flags.oauth;
    }
    inMemoryPersistence() {
        if (this.flags.inMemoryPersistence !== undefined) {
            if (this.flags.location) {
                throw new RangeError(`The --inMemoryPersistence option is not supported when the --location option is set.`);
            }
            return true;
        }
        else {
            if (this.extentMemoryLimit() !== undefined) {
                throw new RangeError(`The --extentMemoryLimit option is only supported when the --inMemoryPersistence option is set.`);
            }
        }
        return false;
    }
    extentMemoryLimit() {
        return this.flags.extentMemoryLimit;
    }
    async debug() {
        if (typeof this.flags.debug === "string") {
            // Enable debug log to file
            return this.flags.debug;
        }
        if (this.flags.debug === true) {
            throw RangeError(`Must provide a debug log file path for parameter -d or --debug`);
        }
        // By default disable debug log
    }
}
exports.default = Environment;
//# sourceMappingURL=Environment.js.map